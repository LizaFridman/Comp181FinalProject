diff --git a/Built-in.scm b/Built-in.scm
new file mode 100755
index 0000000..d239a27
--- /dev/null
+++ b/Built-in.scm
@@ -0,0 +1,48 @@
+(define not
+  (lambda (element)
+    (if element
+	#f
+	#t)))
+
+;;(define +
+;; (letrec ((loop
+;;(lambda (s)
+;; (if (null? s)
+;;   0
+;;  (bin+ (car s)
+;;       (loop (cdr s)))))))
+;;(lambda s (loop s))))
+
+;;(define length
+ ;; (lambda (lst)
+  ;;  (if (null? lst)
+	;;0
+	;;(+ 1 (length (cdr lst))))))
+
+;;(define append
+ ;; (lambda (lst1 lst2)
+  ;;  (cond ((null? lst1)
+	 ;;  lst2)
+	  ;;(else (cons (car lst1)
+		 ;;     (append (cdr lst1) lst2))))))
+(define list
+  (lambda args args))
+
+;;(define fold_left
+  ;;(lambda (proc init lst)
+    ;;(if (null? lst) 
+  ;;	init 
+  ;;	(fold_left proc (proc init (car lst)) (cdr lst)))))
+
+;;(define +
+  ;;(lambda x
+    ;;(fold_left (lambda (acc y)
+		 ;;(b+ acc y))
+	     ;;  0
+	      ;; x)))
+
+;;(define zero?
+  ;;(lambda (element)
+    ;;(and (number? element)
+;;	 (equal? 0 x)))))
+
diff --git a/Compiler.scm b/Compiler.scm
new file mode 100644
index 0000000..ebf9914
--- /dev/null
+++ b/Compiler.scm
@@ -0,0 +1,2920 @@
+(load "project/sexpr-parser.scm")
+(load "project/tag-parser.scm")
+(load "project/semantic-analyzer.scm")
+
+(define to-string
+	(lambda (exp)
+		(cond ((number? exp) (number->string exp))
+              ((symbol? exp) (symbol->string exp))
+              (else exp))))
+;labels:
+(define env_level -1)
+(define label-start-index 1)
+(define update-label
+    (lambda (label_name)
+        (let ((curr-index label-start-index))
+            (set! label-start-index (+ label-start-index 1))
+            (string-append label_name (number->string curr-index)))))
+(define make_label
+	(lambda (label-prefix)
+		(lambda ()
+			(let ((index 0))
+				(lambda ()
+					(set! index (+ index 1))
+					(string-append label-prefix (number->string index)))))))
+(define end_of_code ((make_label "code_end")))
+(define loop_to_copy_args ((make_label "copy_arg_loop")))
+(define end_of_if ((make_label "if_exit")))
+(define error? ((make_label "error?")))
+(define not_pushing ((make_label "don't_push_args")))
+(define global_var ((make_label "global_var")))
+(define loop_to_copy_envs ((make_label "copy_envs_loop")))
+(define else_of_if ((make_label "if_else_")))
+(define end_of_copy_args_lbl ((make_label "end_of_copy_args")))
+(define end_of_of_stack ((make_label "end_of_fix_stack_loop")))
+(define end_of_or ((make_label "or_exit")))
+(define end_of_applic ((make_label "applic_else")))
+(define end_of_copy_envs ((make_label "end_of_copy_envs")))
+(define code ((make_label "code_start")))
+(define new_env ((make_label "new_env")))
+(define loop_to_fix_stack ((make_label "fix_stack_loop")))
+
+(define str-list->delimited-str
+	(lambda (lst)
+		(if (= (length lst) 0) 
+			""
+			(fold-left (lambda (acc x) (string-append acc ", " x))
+						(car lst)
+						(cdr lst)))))
+(define remove-dups
+    (lambda (lst)
+        (fold-left (lambda (acc curr)
+                        (if (not (member curr acc))
+                       (append acc (list curr))
+                       acc
+                       ))
+                    (list)
+                    lst)))
+(define emptry_string?
+	(lambda (str)
+		(= (string-length str) 0)))
+(define string->str-list 
+	(lambda (str)
+		(let* ((ans (fold-left (lambda (acc ch)
+								(let ((this_str (car acc)) (so_far (cdr acc)))
+								(cond ((equal? ch #\nul) ;deal with special chars
+										((equal? ch #\newline)
+										(if (emptry_string? this_str)
+											(cons "" (append so_far (list "CHAR_NEWLINE")))
+											(cons "" (append so_far (list (string-append "\"" this_str "\"")) (list "CHAR_NEWLINE")))))
+										(if (emptry_string? this_str)
+											(cons "" (append so_far (list "CHAR_NUL")))
+											(cons "" (append so_far (list (string-append "\"" this_str "\"")) (list "CHAR_NUL")))))
+									  ((equal? ch #\space) 
+									  	(if (emptry_string? this_str)
+											(cons "" (append so_far (list "CHAR_SPACE")))
+											(cons "" (append so_far (list (string-append "\"" this_str "\"")) (list "CHAR_SPACE")))))
+									  ((equal? ch #\tab)
+										(if (emptry_string? this_str)
+											(cons "" (append so_far (list "CHAR_TAB")))
+											(cons "" (append so_far (list (string-append "\"" this_str "\"")) (list "CHAR_TAB")))))
+									  
+									  ((equal? ch #\return)
+									  	(if (emptry_string? this_str)
+											(cons "" (append so_far (list "CHAR_RETURN")))
+											(cons "" (append so_far (list (string-append "\"" this_str "\"")) (list "CHAR_RETURN")))))
+									  
+									  (else 
+											(cons (string-append this_str (list->string (list ch))) so_far)))))
+
+							  	(list (string))
+							 	(string->list str))))
+			(if (equal? (car ans) "")
+				(cdr ans)
+				(append (cdr ans) (list (string-append  (car ans)))))
+		)
+	))
+
+(define turn_to_ascii_strings
+	(lambda (str)
+		(map (lambda (x) (number->string (char->integer x))) (string->list str))))
+
+
+(define c-table `(,void () ,#t ,#f))
+
+(define add_to_c-table ;takes pe and updates the c-table
+    (lambda (pe)
+        (cond 	((or (null? pe) (not (list? pe))) #f)
+              	((equal? (car pe) 'const)
+              		(let ((val (cadr pe)))
+	                	(cond  	((null? val) #f) 
+	                			((pair? val)
+	                       		 	(begin (add_to_c-table `(const ,(car val)))
+	                               		   (add_to_c-table `(const ,(cdr val)))
+	                               		   (set! c-table (append c-table (list val))))) 
+	                		   	((vector? val)
+	                        		(begin (vector-map (lambda (e) (add_to_c-table `(const ,e))) val)
+	                            	   	   (set! c-table (append c-table (list val)))))
+	                      	   	((and (number? val) (not (integer? val)))
+	                                (let* ((original-num (numerator val))
+	                                	   (original-den (denominator val))
+	                                	   (gcd-val (gcd original-num original-den))
+	                                       (updated-num (/ original-num gcd-val))
+	                                       (updated-den (/ original-den gcd-val)))
+	                                       (begin (add_to_c-table `(const ,updated-num))
+	                                           (add_to_c-table `(const ,updated-den))
+	                                           (set! c-table (append c-table (list val))))))
+	                          	((symbol? val) 
+	                          		(begin 	(set! c-table (append c-table (list (symbol->string val))))
+		                                    (set! c-table (append c-table (list val))))) 
+		                      	(else (set! c-table (append c-table (list val)))))))
+              					(else (map add_to_c-table pe)))))
+                   
+(define remove-duplicates-from-c-table
+    (lambda ()
+        (set! c-table (remove-dups c-table))))
+
+(define get_c_label
+    (lambda(constant tagged-table)
+        (let ((val (cadar tagged-table))
+        	   (var_label (caar tagged-table)))
+        	  (if (equal? constant val)
+        	  		var_label
+        	  	  (get_c_label constant (cdr tagged-table))))))
+                    
+(define add_ids_to_c_table
+    (lambda()
+        (set! c-table 
+        	(fold-left
+                (lambda (acc-table constant)
+                	(let ((const-lbl "const_"))
+                		(append acc-table 
+			                    (list (cond 	
+			                    		((equal? constant void) `(,(update-label const-lbl) ,constant T_VOID))
+			                          	((equal? constant '()) `(,(update-label	const-lbl) ,constant T_NIL))
+			                          	((equal? constant #t) `(,(update-label const-lbl) ,constant T_BOOL))
+			                          	((equal? constant #f) `(,(update-label const-lbl) ,constant T_BOOL))
+			                        	((number? constant)
+			                            	(let* ((original-num (numerator constant))
+			                                	   (original-den (denominator constant))
+			                            		   (gcd-val (gcd original-num original-den))
+			                                       (updated-num (/ original-num gcd-val))
+			                                       (updated-den (/ original-den gcd-val)))
+			                                (if (integer? constant)
+			                                    `(,(update-label const-lbl) ,updated-num T_INTEGER)
+			                                    `(,(update-label const-lbl) ,constant T_FRACTION))))
+			                        	((char? constant) `(,(update-label const-lbl) ,constant T_CHAR))
+				                        ((vector? constant)
+				                                `(,(update-label const-lbl) ,constant T_VECTOR))
+				                        ((string? constant)
+				                                `(,(update-label const-lbl) ,constant T_STRING))
+				                        ((symbol? constant)
+				                            `(,(update-label const-lbl) ,constant T_SYMBOL))
+				                        ((pair? constant)
+				                            `(,(update-label const-lbl) ,constant T_PAIR))
+				                        (else (error 'constant "error in the const table construction"))))))) '() c-table))))
+(define create-c-table ; run this when compilation starts
+	(lambda (exprs)
+		(begin (add_to_c-table exprs)
+			   (remove-duplicates-from-c-table)
+			   (add_ids_to_c_table))))
+(define get-const-string
+	(lambda ()
+		(fold-left
+            (lambda (acc el)
+            	(let ((const-val (cadr el))
+					  (const-label (car el)))
+                    (cond 	
+				    	   	((equal? const-val '()); null
+								(string-append acc (string-append const-label ":\n\t dq SOB_NIL\n")))
+							((equal? const-val #t); bool-t
+								(string-append acc (string-append const-label ":\n\t dq SOB_TRUE\n")))
+							((equal? const-val void)
+								(string-append acc (string-append const-label ":\n\t dq SOB_VOID\n")))
+							((equal? const-val #f); bool-f
+								(string-append acc (string-append const-label ":\n\t dq SOB_FALSE\n")))
+	                    	((number? const-val);num
+	                        	(let* ((original-num (numerator const-val))
+	                        		   (original-den (denominator const-val))
+	                        		   (gcd-val (gcd original-num original-den))
+	                                   (updated-num (/ original-num gcd-val))
+	                                   (updated-den (/ original-den gcd-val)))
+	                            	(if (integer? const-val)
+	                            		(string-append acc (string-append const-label ":\n\t dq MAKE_LITERAL(T_INTEGER, "(number->string updated-num)")\n"));add both
+	                            		(string-append acc (string-append const-label ":\n\t dq MAKE_LITERAL_FRACTION("(get_c_label updated-num c-table) 
+	                            																				  	  ", "(get_c_label updated-den c-table)")\n")))))
+	                    	((char? const-val) ;char
+								(string-append acc (string-append const-label ":\n\t dq MAKE_LITERAL(T_CHAR, "(number->string (char->integer const-val))")\n")))
+	                        ((vector? const-val);vector
+	                            (let ((label-lst (map (lambda (x) (get_c_label x c-table)) (vector->list const-val)))
+	                            	  (vector-len (vector-length const-val)))
+                        			(string-append acc (string-append const-label ":\n\t MAKE_LITERAL_VECTOR " (str-list->delimited-str label-lst)"\n"))))
+	                        ((string? const-val);string
+                        		(string-append acc (string-append const-label ":\n\t MAKE_LITERAL_STRING " (str-list->delimited-str (turn_to_ascii_strings (car (string->str-list const-val))))"\n")))
+	                        ((pair? const-val);pair
+	                        	(string-append acc (string-append const-label ":\n\t dq MAKE_LITERAL_PAIR("(get_c_label (car const-val) c-table)
+	                            																	    ", "(get_c_label (cdr const-val) c-table)")\n")))
+	                        ((symbol? const-val);symbol
+                        		(string-append acc (string-append const-label ":\n\t dq MAKE_LITERAL_SYMBOL("(get_c_label (symbol->string const-val) c-table)")\n")))
+	                        
+	                        (else (error 'constant "error making c-table creation")))))
+                ""
+                c-table)))
+;f-table
+(define string_for_f_table_initialization '((car "car") 
+							   (cdr "cdr")
+							   (cons "cons")
+							   (boolean? "boolean?")
+							   (pair? "pair?")
+							   (char? "char?")
+							   (list "list")
+							   (null? "null?")
+							   (apply "apply")
+							   (integer? "integer?")
+							   (procedure? "procedure?")
+							   (string? "string?")
+							   (symbol? "symbol?")
+							   (vector? "vector?")
+							   (zero? "zero?")
+							   (not "not")
+							   (car "car")
+							   (cdr "cdr")
+							   (number? "number?")
+							   (rational? "rational?") 
+							   (eq? "eq?")
+							   (+ "plus")
+							   (- "minus")
+							   (/ "div")
+							   (* "mul")
+							   (< "less_than")
+							   (> "greater_than")
+							   (= "equal")
+							   (char->integer "char_to_integer")
+							   (integer->char "integer_to_char")
+							   (numerator "numerator")
+							   (string-ref "string_ref")
+							   (vector-ref "vector_ref")
+							   (remainder "remainder")
+							   (denominator "denominator")
+							   (string-length "string_length")
+							   (vector-length "vector_length")
+							   
+							    (string-set! "string_set")
+							   (vector-set! "vector_set")
+							   (bin_equal "bin_equal")
+							   (bin_plus  "bin_plus")
+							   (bin_minus "bin_minus")
+							   (bin_mul   "bin_mul")
+							   (bin_div   "bin_div")
+							   (bin_less_than   "bin_less_than")
+							   (bin_greater_than   "bin_greater_than")
+							  
+							   (make-string "make_string")
+							   (make-vector "make_vector")
+							   (vector "custom_vector")
+							   
+							   (map "map")
+							   
+							   (symbol->string "symbol_to_string")
+							   (string->symbol "string_to_symbol")))
+
+(define global-var-table string_for_f_table_initialization) ;this build the table into global-var-table
+(define add-to-global-var-table
+    (lambda (pe)
+        (cond ((or (not (list? pe)) (null? pe)) #f)
+              ((and (equal? (car pe) 'fvar) (not (assq (cadr pe) string_for_f_table_initialization)))
+                (set! global-var-table (append global-var-table (list (list (cadr pe) (global_var))))))
+              (else (map add-to-global-var-table pe)))))
+
+(define remove-duplicates-from-global-var-table
+    (lambda ()
+        (set! global-var-table (remove-dups global-var-table))))
+
+(define get-label-from-global-var-table
+    (lambda (val curr-var-table)
+        (let* ((curr-row (car curr-var-table))
+        	   (curr-val (car curr-row))
+        	   (curr-label (cadr curr-row)))
+        	  (if (equal? val curr-val)
+        	  		curr-label
+        	  	  (get-label-from-global-var-table val (cdr curr-var-table))))))
+
+(define create-global-var-table
+	(lambda (pe-lst)
+		(begin (add-to-global-var-table pe-lst)
+			   (remove-duplicates-from-global-var-table)
+			)))
+
+(define get-fvar-string
+	(lambda ()
+		(fold-left
+	        (lambda (a b)
+	            	(string-append a (cadr b) ":\n\tdq SOB_UNDEFINED\n"))
+	        (string)
+	        global-var-table)))
+
+;------------------------SYMBOL-TABLE------------------------------
+
+(define count-symbols
+	(lambda ()
+		(fold-left 
+    		(lambda (acc el)
+    			(if (equal? (caddr el) 'T_SYMBOL)
+    				(+ acc 1)
+    				acc))
+    		0
+    		c-table)))
+
+
+
+(define cg-symbol-table 
+    (lambda (curr-c-table index number-of-symbols-left)
+        (if (equal? number-of-symbols-left 0)
+        	(if (equal? index 0)
+                (string-append "symbol_table:\n\t dq const_2\n") 
+            	(string-append "symbol_table:\n\t dq symbol_0\n"))
+            (if (not (null? curr-c-table))
+            	(let* ((el (car curr-c-table)) 
+    		  		  (const-label (car el)) 
+    		  		  (const-val (cadr el)) 
+    		  		  (const-type (caddr el)))
+                	(if (not (equal? const-type 'T_SYMBOL))
+                    	(cg-symbol-table (cdr curr-c-table) index number-of-symbols-left)
+                    	(if (equal? number-of-symbols-left 1)
+							(string-append "symbol_"(number->string index)": 
+								\n\t dq MAKE_LITERAL_PAIR("const-label", const_2)\n" (cg-symbol-table (cdr curr-c-table) (+ index 1) (- number-of-symbols-left 1)))
+							(string-append "symbol_"(number->string index)": 
+								\n\t dq MAKE_LITERAL_PAIR("const-label", symbol_"(number->string (+ index 1))")\n"(cg-symbol-table (cdr curr-c-table) (+ index 1) (- number-of-symbols-left 1))))))
+            (cg-symbol-table (cdr c-table) index number-of-symbols-left)))))
+;cg-code
+(define code_gen
+    (lambda (pe)
+        (cond 
+            ((equal? (car pe) 'if3) (cg-if  pe))
+                        ((equal? (car pe) 'pvar) (cg-pvar pe))
+
+            ((equal? (car pe) 'box-set) (cg-box-set pe))
+            ((equal? (car pe) 'box-get) (cg-box-get pe))
+            ((equal? (car pe) 'seq) (cg-seq pe))
+            ((equal? (car pe) 'or)  (cg-or  pe))
+            ((equal? (car pe) 'set) (cg-set pe))
+            ((equal? (car pe) 'box) (cg-box pe))
+            ((equal? (car pe) 'applic)  (cg-app pe))
+           	((equal? (car pe) 'tc-applic)  (cg-app pe))
+           	((equal? (car pe) 'lambda-simple)  (cg-lambda-simple pe))
+            ((equal? (car pe) 'lambda-opt)  (cg-lambda-opt pe))
+            ((equal? (car pe) 'define) (cg-define pe))
+            ((equal? (car pe) 'const) (cg-const pe))
+            ((equal? (car pe) 'fvar)  (cg-fvar pe))
+            ((equal? (car pe) 'bvar) (cg-bvar pe))
+
+            (else "mov rax, const_4\n")
+        )))
+
+(define cg-define
+    (lambda(pe)
+    	(let ((var-name (cadadr pe)) (pe-val (caddr pe)) (void_lbl "const_1"))
+	        (string-append
+	            (code_gen pe-val)
+	            "mov [" (cadr (assq var-name global-var-table)) "], rax\n"
+	            "mov rax, "void_lbl"\n"))))
+(define cg-const
+    (lambda(pe)
+        (string-append "mov rax, "(to-string (get_c_label (cadr pe) c-table))"\n")))
+(define cg-fvar
+	(lambda(pe)
+		(string-append "mov rax, ["(get-label-from-global-var-table (cadr pe) global-var-table)"]\n")))
+(define cg-or
+    (lambda (expr)
+        (let ((exit (end_of_or)) (arg_start (caadr expr)))
+            (string-append
+                (code_gen arg_start)
+                (fold-right
+                    string-append
+                    ""
+                    (map (lambda (next-el)
+                            (string-append "cmp rax , const_4\n"
+                                           "jne" " " exit "\n"
+                                           (code_gen next-el)))
+                    		(cdadr expr)))
+                exit ":\n"))))
+
+
+
+(define cg-seq
+    (lambda (pe)
+        (fold-left
+            string-append
+            ""
+            (map code_gen (cadr pe)))))
+
+(define cg-app
+    (lambda (pe)
+        (let ((args (reverse (caddr pe))) (func (cadr pe)) (exit (end_of_applic)))
+        (string-append
+        	;"push const_2\n"
+            (fold-left
+                string-append
+                ""
+                (map (lambda (el)
+                    (string-append
+                        (code_gen el)
+                        "push rax\n"))
+                 args))
+            "push "(number->string (length args))"\n"
+			(code_gen func)
+			"\t " "mov rax, [rax]\n"
+			"mov rbx, rax\n"
+			"TYPE rbx\n"
+            "cmp rbx, T_CLOSURE\n"
+            "jne "exit"\n"
+            "\t \t \n"
+            "mov rbx, rax\n"            
+			"CLOSURE_ENV rbx\n"
+			"push rbx\n"	
+            "CLOSURE_CODE rax\n"
+            "call rax\n"
+            exit":\n"
+            "add rsp, " (number->string (* (+ 2 (length args)) 8)) " \n"))))
+
+(define cg-tc-app
+    (lambda (pe)
+        (let ((args (reverse (caddr pe))) (proc (cadr pe)) (exit (end_of_applic)) (loop_to_copy_args (loop_to_copy_args)) (end_of_copy_args (end_of_copy_args_lbl)))
+        (string-append
+        	;"push const_2\n"
+            (fold-left
+                string-append
+                ""
+                (map (lambda (el)
+                    (string-append
+                        (code_gen el)
+                        "push rax\n"))
+                 args))
+            "push "(number->string (length args))"\n"
+			(code_gen proc)
+			"mov rax, [rax]\n"
+			"mov rbx, rax\n"
+			"\t \n TYPE rbx\n"
+            "cmp rbx, T_CLOSURE\n"
+            "jne "exit"\n"
+
+            "mov rbx, rax\n"            
+			"CLOSURE_ENV rbx\n"
+			"push rbx\n"
+			" \t ;; save the ret address \n"
+			"push ret_addr\n" 
+			"mov r9, rbp\n"
+			"mov rbp, qword[r9]\n"
+			"mov r11,rsp\n"
+			"mov r15,arg_count\n"
+			"add r15, 5\n" 
+			" \t ;copy the args \n"
+			"mov rdi, "(number->string (+ (length args) 4)) "\n"
+			loop_to_copy_args":\n"
+			"cmp rdi, 0\n"
+			"je "end_of_copy_args"\n"
+			"mov r10, rdi\n"
+			"dec r10\n"
+			"shl r10, 3\n"
+			"mov r12,qword[r11+r10]\n"
+			"dec r15\n"
+			"mov r10,r15\n"
+			"shl r10, 3\n"
+			"mov qword[r9+r10],r12\n"
+			"dec rdi\n"
+			";\t copy args \n"
+			"jmp "loop_to_copy_args"\n"
+			end_of_copy_args":\n"
+			"mov r10,r15\n"
+			"shl r10, 3\n"
+			"lea rsp,[r9+r10]\n"
+            "CLOSURE_CODE rax\n"
+            "jmp rax\n"
+            exit":\n"
+        	))))
+(define cg-if ;if
+    (lambda (pe)
+        (let ((exit (end_of_if)) (else_part (else_of_if)) (test_if3 (cadr pe)) (if_then_part (caddr pe)) (if_else_part (cadddr pe)))
+            (string-append
+                (code_gen test_if3)
+                "cmp rax, const_4\n"
+                "je "else_part"\n"
+                (code_gen if_then_part)
+                "jmp "exit"\n"
+                else_part":\n"
+                (code_gen if_else_part)
+                exit":\n"))))
+(define cg-lambda-simple ;lambda-simple
+    (lambda (pe)
+        (set! env_level (+ env_level 1))
+            (let* ((args (cadr pe)) (body (caddr pe))
+            	  (end_of_code (end_of_code)) (loop_to_copy_args (loop_to_copy_args)) (end_of_copy_args (end_of_copy_args_lbl))
+            	  (for_copy_envs (loop_to_copy_envs)) (end_of_copy_envs (end_of_copy_envs)) (code_label (code)) (new_env (new_env))
+                  (cg_string (string-append
+                  	;create new env
+                  	"mov rbx, 0\n";env
+                    "mov rax, " (number->string env_level) "\n";major
+                    "cmp rax, 0\n"
+                    "je "end_of_copy_envs"\n"
+                    "mov rdi, "(number->string (* 8 (+ 1 env_level)))"\n";for allocating space for new extended env 
+                    "call malloc\n"
+                    "mov rbx, rax\n"	
+                    
+                    "mov rax, arg_count\n"
+					"mov rdi, 8\n"
+					"mul rdi\n"
+                    "push rbx\n"	
+                    "mov rdi, rax\n"
+                    "call malloc\n"
+                    "pop rbx\n"
+                    "\t "
+                    "mov rcx, rax\n"	
+                    "push rbx\n"
+                    "\t ;copy args \n"
+					"mov rdi, 0\n"
+					"pop rbx\n"
+					loop_to_copy_args":\n"
+					"cmp rdi, arg_count\n"
+					"je "end_of_copy_args"\n"
+					"mov rax, 8\n"
+					"mul rdi\n"
+					"mov rdx, An(rdi)\n"   ; rdx = i'th argument
+					"mov qword [rcx+rax], rdx\n" ; copy arg i into [rcx+8*i]
+					"inc rdi\n"
+
+
+
+
+					"jmp "loop_to_copy_args"\n"
+					end_of_copy_args":\n"
+					"mov qword [rbx], rcx\n"
+					"mov r14, env\n"		; rdx=previous env
+					"cmp r14, 0\n"
+					"je "end_of_copy_envs"\n"
+					"mov rdi, 0\n"
+					for_copy_envs":\n"
+					"cmp rdi, " (number->string env_level) "\n"
+					"je "end_of_copy_envs"\n"
+					"mov rax, 8\n"
+					"mul rdi\n"
+					"mov rcx, qword [r14+rax]\n" ; rcx = i'th env
+					"mov qword [rbx+rax+8], rcx\n" ; copy env i into [rbx+8*i+8]
+					"inc rdi\n"
+					"jmp "for_copy_envs"\n"
+					end_of_copy_envs":\n"
+
+                    ;create target
+                    "push rbx\n"
+                    "push rcx\n"
+                    "mov rdi, 16\n"
+                    "call malloc\n" ;rax = malloc(8*2)
+                    "pop rcx\n"
+                    "pop rbx\n"
+                    "push rbx\n"
+                    "MAKE_LITERAL_CLOSURE rax, rbx, " code_label "\n"
+                    "pop rbx\n"
+                    "jmp "end_of_code"\n"
+					;create code
+					code_label":\n"
+					"push rbp\n"
+					"mov rbp, rsp\n"
+					(code_gen body)
+					"mov rbx, rax\n"
+					"mov rax, arg_count\n"
+					"add rax, 1\n"
+					"mov rdi, 8\n"
+					"mul rdi\n"
+					"add rsp, rax\n"
+					"mov rax, rbx\n"
+					"leave\n"
+					"ret\n"
+					end_of_code":\n")))
+        		(set! env_level (- env_level 1)) 
+        		cg_string)))
+
+(define cg-box-set
+	(lambda (pe)
+		(let ((var (cadr pe)) (val (caddr pe)))
+			(string-append
+				(code_gen val)
+				"mov rbx, rax\n"
+				(code_gen var)
+				"mov qword [rax], rbx\n"
+				"mov rax, const_1\n"
+			))))
+
+(define cg-lambda-opt
+    (lambda (pe)
+        (set! env_level (+ env_level 1))
+            (let* ((args (cadr pe))
+            	   (body (cadddr pe))
+            	   (end_of_code (end_of_code)) (loop_to_copy_args (loop_to_copy_args)) (end_of_copy_args (end_of_copy_args_lbl))
+            	   (for_copy_envs (loop_to_copy_envs)) (end_of_copy_envs (end_of_copy_envs)) (code_label (code)) (new_env (new_env))
+            	   (for_fix_stack (loop_to_fix_stack)) (end_of_fix_stack (end_of_of_stack)) (dont_push_arg_label (not_pushing))
+                   (cg_string (string-append
+                  	;create new env
+                  	"mov rbx, 0\n";env
+                    "mov rax, " (number->string env_level) "\n"
+                    "cmp rax, 0\n"
+                    "je "end_of_copy_envs"\n"
+                    "mov rdi, "(number->string (* 8 (+ 1 env_level)))"\n" 
+                    "call malloc\n"
+                    "mov rbx, rax\n"	 
+                    "mov rax, arg_count\n"
+					"mov rdi, 8\n"
+					"mul rdi\n"
+                    "push rbx\n"	
+                    "mov rdi, rax\n"
+                    "call malloc\n"
+                    "pop rbx\n"
+                    "mov rcx, rax\n"	
+					"mov rdi, 0\n"
+					loop_to_copy_args":\n"
+					"cmp rdi, arg_count\n"
+					"je "end_of_copy_args"\n"
+					"mov rax, 8\n"
+					"mul rdi\n"
+					"mov rdx, An(rdi)\n"  
+					"mov qword [rcx+rax], rdx\n" 
+					"inc rdi\n"
+					"jmp "loop_to_copy_args"\n"
+					end_of_copy_args":\n"
+
+					"mov qword [rbx], rcx\n"
+
+					"mov r14, env\n"		
+					"cmp r14, 0\n"
+					"jle "end_of_copy_envs"\n"
+					"mov rdi, 0\n"
+					for_copy_envs":\n"
+					"cmp rdi, " (number->string env_level) "\n"
+					"je "end_of_copy_envs"\n"
+					"mov rax, 8\n"
+					"mul rdi\n"
+					"mov rcx, qword [r14+rax]\n"
+					"mov qword [rbx+rax+8], rcx\n"
+					"inc rdi\n"
+					"jmp "for_copy_envs"\n"
+					"\t ;copy env in loop \n"
+					end_of_copy_envs":\n"
+                    "push rbx\n"
+                    "push rcx\n"
+                    "mov rdi, 16\n"
+                    "call malloc\n" 
+                    "pop rcx\n"
+                    "pop rbx\n"
+                    "MAKE_LITERAL_CLOSURE rax, rbx, " code_label "\n"
+                    "jmp "end_of_code"\n"
+					code_label":\n"
+					"push rbp\n"
+					"mov rbp, rsp\n"
+					"mov rbx, const_2\n"
+					"mov r12, arg_count\n"
+					for_fix_stack":\n"
+					"cmp r12, "(number->string (length args)) "\n"
+					"je " end_of_fix_stack "\n"
+					"mov rdi, 8\n"
+					"call malloc\n"			
+					"mov rdx, rbp\n"				
+					"add rdx, 4*8\n"	
+					"\t ;stack fixer \n"			
+					"mov r11, r12\n"				
+					"dec r11\n"
+					"shl r11, 3\n"							
+					"add rdx, r11\n"				
+					"mov rdx, qword [rdx]\n"		
+					"MAKE_MALLOC_LITERAL_PAIR rax, rdx, rbx\n"	
+					"\t ;;rax <- target, rbx <- cdr, rcx <- car \n"
+					"mov rbx, rax\n"
+					"push rax\n"				
+					"dec r12\n"		
+					"pop rax\n"			
+					"jmp " for_fix_stack "\n"
+					
+					end_of_fix_stack":\n"
+					"cmp rbx, const_2\n"
+					"\t; ---------------------dont push the args! \n"
+					"mov qword [rbp+4*8+"(number->string (length args))"*8], rbx\n"	;add the list in stack after const params (not optinals)
+					(code_gen body)
+					"leave\n"
+					"ret\n"
+					end_of_code":\n")))
+        (set! env_level (- env_level 1)) 
+	cg_string)))
+
+(define cg-pvar
+	(lambda (pe)
+		(let ((minor (caddr pe)))
+			(string-append "mov rax, qword [rbp+32+"(number->string minor)"*8]\n"))))
+(define cg-box
+	(lambda (pe)
+		(let ((var (cadr pe)))
+			(string-append
+				(code_gen var)
+				"mov rbx, rax\n"
+				"mov rdi, 8\n"
+				"call malloc\n"
+				"mov qword [rax], rbx\n"
+			))))
+
+(define cg-box-get
+	(lambda (pe)
+		(let ((var (cadr pe)))
+			(string-append
+				(code_gen var)
+				"mov qword rax, [rax]\n"
+			))))
+(define cg-bvar
+	(lambda (pe)
+		(let ((major (caddr pe)) (minor (cadddr pe)))
+			(string-append 
+			"mov rax, qword [rbp+16]\n"
+			"mov rax, qword [rax+"(number->string major)"*8]\n"
+			"mov rax, qword [rax+"(number->string minor)"*8]\n"
+			))))
+
+(define cg-set
+	(lambda (pe)
+		(let ((tag (caadr pe))
+               (var (cadadr pe))
+               (val (caddr pe)))
+			(cond 
+                   ((equal? tag 'bvar)
+                    (let ((major (car (cddadr pe)))
+                         (minor (car(cdr (cddadr pe)))))
+                            (string-append
+                                (code_gen val)
+                                "mov rbx, qword [rbp+16]\n"
+                                "mov rbx, qword [rbx+8*"(number->string major)"]\n"
+                                "mov qword [rbx+8*"(number->string minor)"], rax\n"
+								"mov rax, const_1\n")))
+                   ((equal? tag 'pvar) 
+                    (let ((minor (car (cddadr pe))))
+						(string-append
+						(code_gen val)
+						"mov qword [rbp+8*(4+"(number->string minor)")], rax\n"
+						"mov rax, const_1\n"
+						)))
+                       ((equal? tag 'fvar) 
+                            (string-append
+                                (code_gen val)
+                                "mov ["(get-label-from-global-var-table var global-var-table)"], rax\n"
+                                "mov rax, const_1\n"
+                                ))
+                      (else "wrong input")))))
+
+
+
+
+;built-in
+(define append_build_in_funcs
+	(lambda (lst) (append (string->list (string-append lib-map lib-list lib-fold-left lib-bin-append lib-append 
+				   						 				lib-equal lib-greater-than lib-less-than lib-less-than lib-plus lib-minus lib-mul lib-div )) lst)))
+(define lib-map "(define map (lambda (proc lst) (if (null? lst) 
+													lst 
+													(cons (proc (car lst)) (map proc (cdr lst))))))\n")
+(define lib-list "(define list (lambda x x))\n")
+(define lib-fold-left "(define fold_left (lambda (proc init lst) (if (null? lst) 
+																	 init 
+																	 (fold_left proc (proc init (car lst)) (cdr lst)))))\n")
+(define lib-bin-append "(define bin_append (lambda (lst1 lst2) (if (null? lst1) 
+																	lst2 
+																	(cons (car lst1) (bin_append (cdr lst1) lst2)))))\n")
+(define lib-append "(define append (lambda x (fold_left bin_append '() x)))\n")
+(define lib-equal "(define = (lambda x (fold_left (lambda (acc y) (and acc (bin_equal (car x) y))) #t x)))\n")
+(define lib-greater-than "(define > (lambda x (if (null? (cdr x))
+												  #t 
+												  (and (bin_greater_than (car x) (car (cdr x))) (apply > (cdr x)))))) \n")
+(define lib-less-than "(define < (lambda x (if (null? (cdr x)) 
+												#t 
+												(and (bin_less_than (car x) (car (cdr x))) (apply < (cdr x)))))) \n")
+(define lib-plus "(define + (lambda x (fold_left (lambda (acc y) (bin_plus acc y)) 0 x)))\n")
+
+(define lib-minus "(define - (lambda x (if (null? (cdr x)) 
+											(bin_minus 0 (car x)) 
+											(fold_left (lambda (acc y) (bin_minus acc y)) (car x) (cdr x)))))\n")
+(define lib-mul "(define * (lambda x (fold_left (lambda (acc y) (bin_mul acc y)) 1 x)))\n")
+
+(define lib-div "(define / (lambda x (if (null? (cdr x)) 
+										 (bin_div 1 (car x)) 
+										 (fold_left (lambda (acc y) (bin_div acc y)) (car x) (cdr x)))))\n")
+
+(define code-cg-library-functions
+    (lambda ()
+        (string-append
+            (cg-cons)
+            (cg-car)
+            (cg-cdr)
+            (cg-null?)
+            (cg-pair?)
+            (cg-boolean?)
+            (cg-char?)
+            (cg-integer?)
+            (cg-procedure?)
+            (cg-string?)
+            (cg-symbol?)
+            (cg-vector?)
+            (cg-zero?)
+            (cg-apply)
+            (cg-make-string)
+            (cg-make-vector)
+            (cg-not)
+            (cg-string-length)
+            (cg-vector-length)
+            (cg-vector)
+            (cg-char->integer)
+            (cg-integer->char)
+            (cg-string-ref)
+            (cg-vector-ref)
+            (cg-symbol->string)
+            (cg-string->symbol)
+            (cg-bin-mul)
+            (cg-bin-div)
+            (cg-bin-minus)
+            (cg-bin-equal)
+            (cg-bin-less-than)
+            (cg-bin-greater-than)
+            (cg-string-set)
+            (cg-vector-set)
+            (cg-bin-plus)
+            (cg-remainder)
+            (cg-denominator)
+            (cg-numerator)
+            (cg-number?)
+            (cg-rational?)
+            (cg-eq?)
+            )))
+
+(define type_checking
+
+    (lambda (var_type tag)
+    	(let ((low_case (string-downcase var_type)))
+	        (string-append
+	           low_case":\n"
+	           "\t push rbx \n"
+	            "mov rdi, 16\n"
+	            "call malloc\n"
+	            "\t ;malloc is called here \n"
+	            "\t pop rbx  \n"
+	            "mov rbx, qword 0\n"
+	            "MAKE_LITERAL_CLOSURE rax, rbx, "low_case"_body\n"
+	            "mov ["(symbol->string tag)"], rax\n"
+	            "jmp "low_case"_exit\n"
+	            low_case"_body:\n"
+	            "push rbp\n"
+				"mov rbp, rsp\n"
+	            "mov rbx, arg_count\n"
+	            "cmp rbx, 1\n"
+	 			"jne "low_case"_exit\n"
+	            "mov r12, An(0)\n"
+	            "mov r12, [r12]\n"
+	            "TYPE r12\n"
+	            "cmp r12, T_"var_type"\n"
+	            "jne "low_case"_not\n"
+	            "mov rax, const_3\n" 
+	            "jmp "low_case"_finish\n"
+	            low_case"_not:\n"
+	            "mov rax, const_4\n"
+	           	low_case"_finish:\n"
+	            "leave\n"
+				"ret\n"
+	            low_case"_exit:\n"))))
+        
+     (define cg-integer?
+    (lambda()
+        (type_checking "INTEGER" 'integer?)))
+        
+(define cg-procedure?
+    (lambda()
+        (type_checking "CLOSURE" 'procedure?)))
+        
+(define cg-string?
+    (lambda()
+        (type_checking "STRING" 'string?)))   
+(define cg-null?
+    (lambda()
+        (type_checking "NIL" 'null?)))
+
+(define cg-pair?
+    (lambda()
+        (type_checking "PAIR" 'pair?)))
+        
+(define cg-boolean?
+    (lambda()
+        (type_checking "BOOL" 'boolean?)))
+        (define cg-symbol?
+    (lambda()
+        (type_checking "SYMBOL" 'symbol?)))
+(define cg-vector?
+    (lambda()
+        (type_checking "VECTOR" 'vector?)))
+(define cg-char?
+    (lambda()
+        (type_checking "CHAR" 'char?)))
+(define cg-zero?
+    (lambda()
+        (string-append
+            "push rbx\n"
+            "mov rdi, 16\n"
+            "pop rbx\n"
+            "call malloc\n"
+            "mov rbx, qword 0\n"
+            "MAKE_LITERAL_CLOSURE rax, rbx, zero?_body\n"
+            "mov [zero?], rax\n"
+            "jmp zero?_exit\n"  
+            "zero?_body:\n"        
+        	"push rbp\n"
+			"mov rbp, rsp\n"         
+            "mov rbx, arg_count\n"
+            "push rcx\n"
+	        "cmp rbx, 1\n" 
+	        "pop rcx\n"
+	 		"jne zero_finish\n"
+	 		"mov rax, An(0)\n"
+	        "mov rax, [rax]\n"
+	        "TYPE rax\n"
+	        "cmp rax, T_INTEGER\n"
+	        "je zero_check\n"
+	        "cmp rax, T_FRACTION\n"
+	        "jne zero_finish\n"
+	        "zero_check:\n"
+	        "mov rax, An(0)\n"
+	        "mov rax, [rax]\n"
+	        "DATA rax\n"
+	        "cmp rax, 0\n"
+	        "je zero_true\n"
+	        "mov rax, const_4\n"
+	        "jmp zero_finish\n"
+	        "zero_true:\n"
+	        "mov rax, const_3\n"
+
+	        "zero_finish:\n"
+	        "leave\n"
+	        "ret\n"
+	        "zero?_exit:\n" )))
+
+(define cg-number?
+    (lambda()
+        (string-append
+            "mov rdi, 16\n"
+            "call malloc\n"
+            "mov rbx, qword 0\n"
+            "MAKE_LITERAL_CLOSURE rax, rbx, number?_body\n"
+            "mov [number?], rax\n"
+            "jmp number?_exit\n"
+            
+            "number?_body:\n"
+        	"push rbp\n"
+			"mov rbp, rsp\n"         
+            "mov rbx, arg_count\n"
+	        "cmp rbx, 1\n" 
+	 		"jne number?_finish\n"
+	 		
+	 		"mov rax, An(0)\n"
+	        "mov rax, [rax]\n"
+	        "TYPE rax\n"
+	        "cmp rax, T_INTEGER\n"
+	        "je number?_true\n"
+	        "cmp rax, T_FRACTION\n"
+	        "je number?_true\n"
+	        "mov rax, const_4\n"
+	        "jmp number?_finish\n"
+	        
+	        "number?_true:\n"
+	        "mov rax, const_3\n"
+
+	        "number?_finish:\n"
+	        "leave\n"
+	        "ret\n"
+	        "number?_exit:\n" )))
+
+(define cg-not
+    (lambda ()
+        (string-append
+            "mov rdi, 16\n"
+            "call malloc\n"
+            "mov rbx, qword 0\n"
+            "MAKE_LITERAL_CLOSURE rax, rbx, not_body\n"
+            "mov [not], rax\n"
+            "jmp not_exit\n"
+            
+            "not_body:\n"
+            "push rbp\n"
+			"mov rbp, rsp\n"         
+            "mov rbx, arg_count\n"
+	        "cmp rbx, 1\n" ; pop n from stack
+	 		"jne not_exit\n"
+            "mov rax, An(0)\n"
+	        "mov rax, [rax]\n"
+	        "cmp rax, [const_4]\n"
+	        "je is_false\n"
+	        "mov rax, const_4\n"
+	        "jmp not_finish\n"
+	        "is_false:\n"
+	        "mov rax, const_3\n"
+	        "not_finish:\n"
+	        "leave\n"
+	        "ret\n"
+
+            "not_exit:\n")))
+
+(define cg-car
+    (lambda()
+        (string-append
+            "mov rdi, 16\n"
+            "call malloc\n"
+            "mov rbx, qword 0\n"
+            "MAKE_LITERAL_CLOSURE rax, rbx, car_body\n"
+            "mov [car], rax\n"
+            "jmp car_exit\n"
+            
+            "car_body:\n"
+            "push rbp\n"
+			"mov rbp, rsp\n"       
+            "mov rax, An(0)\n"
+            "mov rax, [rax]\n"
+            "DATA_UPPER rax\n"
+			"add rax, start_of_data\n"
+            "leave\n"
+            "ret\n"
+            
+            "car_exit:\n")))
+
+(define cg-cdr
+    (lambda()
+        (string-append
+            "mov rdi, 16\n"
+            "call malloc\n"
+            "mov rbx, qword 0\n"
+            "MAKE_LITERAL_CLOSURE rax, rbx, cdr_body\n"
+            "mov [cdr], rax\n"
+            "jmp cdr_exit\n"
+            
+            "cdr_body:\n"
+            "push rbp\n"
+			"mov rbp, rsp\n"       
+            "mov rax, An(0)\n"
+            "mov rax, [rax]\n"
+            "DATA_LOWER rax\n"
+			"add rax, start_of_data\n"
+            "leave\n"
+            "ret\n"
+            
+            "cdr_exit:\n")))
+
+(define cg-cons
+    (lambda()
+        (string-append
+            
+            "mov rdi, 16\n"
+            "call malloc\n"
+            "mov rbx, qword 0\n"
+            "MAKE_LITERAL_CLOSURE rax, rbx, cons_body\n"
+            "mov [cons], rax\n"
+            "jmp cons_exit\n"
+            
+            "cons_body:\n"
+            "push rbp\n"
+			"mov rbp, rsp\n"
+			"mov rbx, arg_count\n"
+	        "cmp rbx, 2\n" 
+	 		"jne cons_finish\n"
+            "mov rdi, 8\n"
+            "call malloc\n"
+            "mov rcx, An(0)\n"
+            "mov rdx, An(1)\n"
+            "MAKE_MALLOC_LITERAL_PAIR rax, rcx, rdx\n"
+            "cons_finish:\n"
+        	"leave\n"
+            "ret\n"
+            
+            "cons_exit:\n")))
+
+(define cg-rational?
+ 	(lambda()       
+		(string-append
+            "mov rdi, 16\n"
+            "call malloc\n"
+            "mov rbx, qword 0\n"
+            "MAKE_LITERAL_CLOSURE rax, rbx, rational?_body\n"
+            "mov [rational?], rax\n"
+            "jmp rational?_exit\n"
+            
+            "rational?_body:\n"
+        	"push rbp\n"
+			"mov rbp, rsp\n"         
+            "mov rbx, arg_count\n"
+	        "cmp rbx, 1\n" 
+	 		"jne rational?_finish\n"
+
+	 		"mov rax, An(0)\n"
+	        "mov rax, [rax]\n"
+	        "TYPE rax\n"
+	        "cmp rax, T_INTEGER\n"
+	        "je rational?_true\n"
+	        "cmp rax, T_FRACTION\n"
+	        "je rational?_true\n"
+	        "mov rax, const_4\n"
+	        "jmp rational?_finish\n"
+	        
+	        "rational?_true:\n"
+	        "mov rax, const_3\n"
+
+	        "rational?_finish:\n"
+	        "leave\n"
+	        "ret\n"
+	        "rational?_exit:\n" )))
+
+(define cg-eq?
+ 	(lambda()       
+		(string-append
+            "mov rdi, 16\n"
+            "call malloc\n"
+            "mov rbx, qword 0\n"
+            "MAKE_LITERAL_CLOSURE rax, rbx, eq?_body\n"
+            "mov [eq?], rax\n"
+            "jmp eq?_exit\n"
+            
+            "eq?_body:\n"
+        	"push rbp\n"
+			"mov rbp, rsp\n"         
+            "mov rbx, arg_count\n"
+	        "cmp rbx, 2\n" 
+	 		"jne eq?_finish\n"
+
+	 		"mov rax, An(0)\n"
+	 		"mov rax, [rax]\n"
+	 		"mov rbx, An(1)\n"
+	 		"mov rbx, [rbx]\n"
+	        "cmp rax, rbx\n"
+	        "je eq?_true\n"
+	        "mov rax, const_4\n"
+	        "jmp eq?_finish\n"
+	        
+	        "eq?_true:\n"
+	        "mov rax, const_3\n"
+
+	        "eq?_finish:\n"
+	        "leave\n"
+	        "ret\n"
+	        "eq?_exit:\n" )))
+
+(define cg-bin-equal
+ 	(lambda()       
+		(string-append
+            "mov rdi, 16\n"
+            "call malloc\n"
+            "mov rbx, qword 0\n"
+            "MAKE_LITERAL_CLOSURE rax, rbx, bin_equal_body\n"
+            "mov [bin_equal], rax\n"
+            "jmp bin_equal_exit\n"
+            
+            "bin_equal_body:\n"
+        	"push rbp\n"
+			"mov rbp, rsp\n"         
+            "mov rbx, arg_count\n"
+	        "cmp rbx, 2\n" 
+	 		"jne bin_equal_finish\n"
+
+	 		"mov rax, An(0)\n"
+	 		"mov rax, [rax]\n"
+	 		"mov rcx, rax\n"
+	 		"mov rbx, An(1)\n"
+	 		"mov rbx, [rbx]\n"
+	 		"mov rdx, rbx\n"
+	 		"TYPE rax\n"
+	 		"TYPE rbx\n"
+	        
+	        "cmp rax, T_INTEGER\n"
+	        "jne check_fraction\n"
+	        "cmp rbx, T_INTEGER\n"
+	        "jne bin_equal_false\n"
+	        
+	        "DATA rcx\n"
+	        "DATA rdx\n"
+	        "cmp rcx, rdx\n"
+	        "jne bin_equal_false\n"
+	        "mov rax, const_3\n"
+	        "jmp bin_equal_finish\n"
+
+	        "check_fraction:\n"
+	        "cmp rax, T_FRACTION\n"
+	        "jne bin_equal_finish\n"
+	        "cmp rbx, T_FRACTION\n"
+	        "jne bin_equal_false\n"
+
+	        "mov r9, rcx\n"
+	        "mov r8, rdx\n"
+	        "CAR rcx\n"
+	        "CAR rdx\n"
+	        "cmp rcx, rdx\n"
+	        "jne bin_equal_false\n"
+	        "CDR r9\n"
+	        "CDR r8\n"
+	        "cmp r9, r8\n"
+	        "jne bin_equal_false\n"
+	        "mov rax, const_3\n"
+	        "jmp bin_equal_finish\n"
+
+	        "bin_equal_false:\n"
+	        "mov rax, const_4\n"
+
+	        "bin_equal_finish:\n"
+	        "leave\n"
+	        "ret\n"
+	        "bin_equal_exit:\n" )))
+
+(define cg-bin-plus
+	(lambda ()
+		(string-append
+            "mov rdi, 16\n"
+            "call malloc\n"
+            "mov rbx, qword 0\n"
+            "MAKE_LITERAL_CLOSURE rax, rbx, bin_plus_body\n"
+            "mov [bin_plus], rax\n"
+            "jmp bin_plus_exit\n"
+            
+            "bin_plus_body:\n"
+        	"push rbp\n"
+      		"mov rbp, rsp\n"
+      		"mov rcx ,arg_count\n"
+      		"mov rax ,An(0)\n"                
+
+      		"cmp rcx, 2\n"         			; nil + 1 arguments?
+      		"jne bin_plus_finish\n"
+     
+      		"mov rax ,qword [rax]\n"                     
+      		"mov rcx, rax\n"
+      		"TYPE rcx\n"
+      		"cmp rcx, T_INTEGER\n"
+      		"je bin_plus_arg1_int_check_arg2\n"
+      
+      		"bin_plus_arg1_frac_check_arg2:\n"
+      		"mov rbx, An(1)\n"
+       		"mov rbx, qword [rbx]\n"                    
+      		"mov rcx, rbx\n"
+      		"TYPE rcx\n"
+      		"cmp rcx, T_INTEGER\n"
+      		"jne bin_plus_arg1_frac_arg2_frac\n"
+      		"mov r12, rax\n"
+      		"mov rax, rbx\n"
+      		"mov rbx, r12\n"
+      		"jmp bin_plus_arg1_int_arg2_frac\n"
+      
+      		"bin_plus_arg1_frac_arg2_frac:\n"
+      		"mov rcx, rax\n"				
+      		"CAR rcx\n"
+      		"DATA rcx\n"					;rcx holds arg1 numerator	
+      		"mov r11, rax\n"      			;rdx keeps rax value
+      		"CDR r11\n"
+      		"DATA r11\n"
+      
+     		"mov r12, rbx\n"					
+      		"CAR r12\n"
+      		"DATA r12\n"					;r12 holds arg2 numerator
+      		"mov r10, rbx\n"				;r10 keeps r12 value
+      		"CDR r10\n"
+      		"DATA r10\n"
+      		"mov r9, r11\n"					;backup first denominator
+
+      		"MULT r11, r10\n"				;now r11 holds arg1 denominator * arg2 denominator
+      		"MULT rcx, r10\n"				;now rcx holds arg1 numerator * arg2 denominator
+      		"MULT r12, r9\n"				;now r12 holds second numerator * arg1 denominator
+      		"add rcx, r12\n"
+      		"mov rax, rcx\n"	
+      		"mov r10, r11\n"					
+      		"jmp bin_plus_simplify_and_create_fraction\n"                                             
+      		
+		  	"bin_plus_arg1_int_check_arg2:\n"
+		  	"mov rbx, An(1)\n"
+		  	"mov rbx, qword [rbx]\n"                    
+		  	"mov rdx, rbx\n"
+		  	"TYPE rdx\n"
+		  	"cmp rdx, T_INTEGER\n"
+		  	"je bin_plus_arg1_int_arg2_int\n"
+
+		  	"bin_plus_arg1_int_arg2_frac:\n"
+		  	"mov r12, rbx\n"
+		  	"CAR r12\n"
+		  	"DATA r12\n";we will put in r12 second_numerator
+		  	"mov r10, rbx\n"
+		  	"CDR r10\n"
+		  	"DATA r10\n";we will put in r10 second_denominator
+		  	"mov r9,rax\n"
+		  	"DATA r9\n"
+		  	"MULT r9,r10\n"
+		  	"mov rax,r9\n";now rax holds first_numerator*second_denominator
+		  	"add rax,r12\n"
+
+		  	;rax holds new numerator
+		  	;r10 holds new denominator
+		  	"bin_plus_simplify_and_create_fraction:\n"
+		  	"mov r9,  rax\n"
+		  	"mov r8, r10\n"
+		  	"push r8\n"
+		  	"push r9\n"
+		  	"call simplify_fraction\n"
+		  	"add rsp, 16\n"
+		  	"jmp bin_plus_create_new_fraction\n"
+
+		  	"bin_plus_arg1_int_arg2_int:\n"
+		  	"DATA rbx\n" 
+		  	"DATA rax\n"      
+		  	"add rbx,rax\n"
+		  	"shl rbx, 4\n"
+		  	"or rbx, T_INTEGER\n"
+		  	"push rbx\n"
+		  	"mov rdi, 8\n"
+		  	"call malloc\n"
+		  	"pop rbx\n"
+		  	"mov [rax],rbx\n"
+		                        
+		  	"jmp bin_plus_finish\n"                     
+                    
+		  	"bin_plus_create_new_fraction:\n"
+		  	"cmp r8, 1\n"
+		  	"je bin_plus_create_new_int\n"
+
+		  	"shl r9, 4\n"
+		  	"or r9, T_INTEGER\n"		;r9 holds numerator in data structure
+		  	"shl r8, 4\n"
+		  	"or r8, T_INTEGER\n"		;r8 holds denominator in data structure
+		    
+		    "mov rdi, 8\n"
+		    "call malloc\n"
+		    "mov rbx, rax\n"
+		    "mov [rbx], r9\n"
+		    "push rbx\n"
+
+		    "mov rdi, 8\n"
+		    "call malloc\n"
+		    "pop rbx\n"
+		    "mov rcx, rax\n"
+		    "mov [rcx], r8\n"
+		    "push rbx\n"
+		    "push rcx\n"
+
+		    "mov rdi, 8\n"
+		    "call malloc\n" 
+		    "pop rcx\n"
+		    "pop rbx\n"
+                                               
+		  	"MAKE_LITERAL_FRACTION_WITH_REGS rax, rbx, rcx\n"
+		  	"jmp bin_plus_finish\n"
+		          
+		   	"bin_plus_create_new_int:\n"
+
+		   	"shl r9, 4\n"
+		  	"or r9, T_INTEGER\n"
+		  	"push r9\n"
+
+		  	"mov rdi, 8\n"
+		    "call malloc\n"
+		    "pop r9\n"
+		    "mov [rax], r9\n"
+          
+	        "bin_plus_finish:\n"
+	        "leave\n"
+	        "ret\n"
+	        "bin_plus_exit:\n")))
+
+(define cg-bin-minus
+	(lambda ()
+		(string-append
+            "mov rdi, 16\n"
+            "call malloc\n"
+            "mov rbx, qword 0\n"
+            "MAKE_LITERAL_CLOSURE rax, rbx, bin_minus_body\n"
+            "mov [bin_minus], rax\n"
+            "jmp bin_minus_exit\n"
+            
+            "bin_minus_body:\n"
+        	"push rbp\n"
+      		"mov rbp, rsp\n"
+      		"mov rcx ,arg_count\n"
+      		"mov rax ,An(0)\n"                
+
+      		"cmp rcx, 2\n"         			; nil + 1 arguments?
+      		"jne bin_minus_finish\n"
+     
+      		"mov rax ,qword [rax]\n"                     
+      		"mov rcx, rax\n"
+      		"TYPE rcx\n"
+      		"cmp rcx, T_INTEGER\n"
+      		"je bin_minus_arg1_int_check_arg2\n"
+      
+      		"bin_minus_arg1_frac_check_arg2:\n"
+      		"mov rbx, An(1)\n"
+       		"mov rbx, qword [rbx]\n"                    
+      		"mov rcx, rbx\n"
+      		"TYPE rcx\n"
+      		"cmp rcx, T_INTEGER\n"
+      		"je bin_minus_arg1_frac_arg2_int\n"
+   
+      		"bin_minus_arg1_frac_arg2_frac:\n"
+      		"mov rcx, rax\n"				
+      		"CAR rcx\n"
+      		"DATA rcx\n"					;rcx holds arg1 numerator	
+      		"mov r11, rax\n"      			;rdx keeps rax value
+      		"CDR r11\n"
+      		"DATA r11\n"
+      
+     		"mov r12, rbx\n"					
+      		"CAR r12\n"
+      		"DATA r12\n"					;r12 holds arg2 numerator
+      		"mov r10, rbx\n"				;r10 keeps r12 value
+      		"CDR r10\n"
+      		"DATA r10\n"
+      		"mov r9, r11\n"					;backup first denominator
+
+      		"MULT r11, r10\n"				;now r11 holds arg1 denominator * arg2 denominator
+      		"MULT rcx, r10\n"				;now rcx holds arg1 numerator * arg2 denominator
+      		"MULT r12, r9\n"				;now r12 holds second numerator * arg1 denominator
+      		"sub rcx, r12\n"
+      		"mov rax, rcx\n"	
+      		"mov r10, r11\n"					
+      		"jmp bin_minus_simplify_and_create_fraction\n"                                             
+      		
+		  	"bin_minus_arg1_int_check_arg2:\n"
+		  	"mov rbx, An(1)\n"
+		  	"mov rbx, qword [rbx]\n"                    
+		  	"mov rdx, rbx\n"
+		  	"TYPE rdx\n"
+		  	"cmp rdx, T_INTEGER\n"
+		  	"je bin_minus_arg1_int_arg2_int\n"
+
+		  	"bin_minus_arg1_int_arg2_frac:\n"
+		  	"mov r12, rbx\n"
+		  	"CAR r12\n"
+		  	"DATA r12\n";we will put in r12 second_numerator
+		  	"mov r10, rbx\n"
+		  	"CDR r10\n"
+		  	"DATA r10\n";we will put in r10 second_denominator
+		  	"mov r9,rax\n"
+		  	"DATA r9\n"
+		  	"MULT r9,r10\n"
+		  	"mov rax,r9\n";now rax holds first_numerator*second_denominator
+		  	"sub rax,r12\n"
+		  	"jmp bin_minus_simplify_and_create_fraction\n"
+
+		  	"bin_minus_arg1_frac_arg2_int:\n"
+		  	"mov r12, rax\n"
+		  	"CAR r12\n"
+		  	"DATA r12\n"
+		  	"mov r10, rax\n"
+		  	"CDR r10\n"
+		  	"DATA r10\n"
+		  	"mov r9,rbx\n"
+		  	"DATA r9\n"
+		  	"MULT r9,r10\n"
+		  	"mov rax,r9\n";now rax holds first_numerator*second_denominator
+		  	"sub r12, rax\n"
+		  	"mov rax, r12\n"
+
+		  	;rax holds new numerator
+		  	;r10 holds new denominator
+		  	"bin_minus_simplify_and_create_fraction:\n"
+		  	"mov r9,  rax\n"
+		  	"mov r8, r10\n"
+		  	"push r8\n"
+		  	"push r9\n"
+		  	"call simplify_fraction\n"
+		  	"add rsp, 16\n"
+		  	"jmp bin_minus_create_new_fraction\n"
+
+		  	"bin_minus_arg1_int_arg2_int:\n"
+		  	"DATA rbx\n" 
+		  	"DATA rax\n"      
+		  	"sub rax, rbx\n"
+		  	"mov r12, rax\n"
+		  	"shl r12, 4\n"
+		  	"or r12, T_INTEGER\n"
+		  	"push r12\n"
+		  	"mov rdi, 8\n"
+		  	"call malloc\n"
+		  	"pop r12\n"
+		  	"mov [rax],r12\n"
+		                        
+		  	"jmp bin_minus_finish\n"                     
+                    
+		  	"bin_minus_create_new_fraction:\n"
+		  	"cmp r8, 1\n"
+		  	"je bin_minus_create_new_int\n"
+
+		  	"shl r9, 4\n"
+		  	"or r9, T_INTEGER\n"		;r9 holds numerator in data structure
+		  	"shl r8, 4\n"
+		  	"or r8, T_INTEGER\n"		;r8 holds denominator in data structure
+		    
+		    "mov rdi, 8\n"
+		    "call malloc\n"
+		    "mov rbx, rax\n"
+		    "mov [rbx], r9\n"
+		    "push rbx\n"
+
+		    "mov rdi, 8\n"
+		    "call malloc\n"
+		    "pop rbx\n"
+		    "mov rcx, rax\n"
+		    "mov [rcx], r8\n"
+		    "push rbx\n"
+		    "push rcx\n"
+
+		    "mov rdi, 8\n"
+		    "call malloc\n" 
+		    "pop rcx\n"
+		    "pop rbx\n"
+                                              
+		  	"MAKE_LITERAL_FRACTION_WITH_REGS rax, rbx, rcx\n"      
+		  	"jmp bin_minus_finish\n"
+		          
+		   	"bin_minus_create_new_int:\n"
+
+		   	"shl r9, 4\n"
+		  	"or r9, T_INTEGER\n"
+		  	"push r9\n"
+
+		  	"mov rdi, 8\n"
+		    "call malloc\n"
+		    "pop r9\n"
+		    "mov [rax], r9\n"
+          
+	        "bin_minus_finish:\n"
+	        "leave\n"
+	        "ret\n"
+	        "bin_minus_exit:\n")))
+
+(define cg-bin-mul
+	(lambda ()
+		(string-append
+            "mov rdi, 16\n"
+            "call malloc\n"
+            "mov rbx, qword 0\n"
+            "MAKE_LITERAL_CLOSURE rax, rbx, bin_mul_body\n"
+            "mov [bin_mul], rax\n"
+            "jmp bin_mul_exit\n"
+            
+            "bin_mul_body:\n"
+        	"push rbp\n"
+      		"mov rbp, rsp\n"
+      		"mov rcx ,arg_count\n"
+      		"mov rax ,An(0)\n"                
+
+      		"cmp rcx, 2\n"         			; nil + 1 arguments?
+      		"jne bin_mul_finish\n"
+     
+      		"mov rax ,qword [rax]\n"                     
+      		"mov rcx, rax\n"
+      		"TYPE rcx\n"
+      		"cmp rcx, T_INTEGER\n"
+      		"je bin_mul_arg1_int_check_arg2\n"
+      
+      		"bin_mul_arg1_frac_check_arg2:\n"
+      		"mov rbx, An(1)\n"
+       		"mov rbx, qword [rbx]\n"                    
+      		"mov rcx, rbx\n"
+      		"TYPE rcx\n"
+      		"cmp rcx, T_INTEGER\n"
+      		"jne bin_mul_arg1_frac_arg2_frac\n"
+      		"mov r12, rax\n"
+      		"mov rax, rbx\n"
+      		"mov rbx, r12\n"
+      		"jmp bin_mul_arg1_int_arg2_frac\n"
+      
+      		"bin_mul_arg1_frac_arg2_frac:\n"
+      		"mov rcx, rax\n"				
+      		"CAR rcx\n"
+      		"DATA rcx\n"					;rcx holds arg1 numerator	
+      		"mov r11, rax\n"      			;rdx keeps rax value
+      		"CDR r11\n"
+      		"DATA r11\n"
+      
+     		"mov r12, rbx\n"					
+      		"CAR r12\n"
+      		"DATA r12\n"					;r12 holds arg2 numerator
+      		"mov r10, rbx\n"				;r10 keeps r12 value
+      		"CDR r10\n"
+      		"DATA r10\n"
+      		"mov r9, r11\n"					;backup first denominator
+
+      		"MULT r11, r10\n"				;now r11 holds arg1 denominator * arg2 denominator
+      		"MULT r12, rcx\n"				;now r12 holds arg1 numerator * arg2 numerator
+      		"mov rax, r12\n"	
+      		"mov r10, r11\n"					
+      		"jmp bin_mul_simplify_and_create_fraction\n"                                             
+      		
+		  	"bin_mul_arg1_int_check_arg2:\n"
+		  	"mov rbx, An(1)\n"
+		  	"mov rbx, qword [rbx]\n"                    
+		  	"mov rdx, rbx\n"
+		  	"TYPE rdx\n"
+		  	"cmp rdx, T_INTEGER\n"
+		  	"je bin_mul_arg1_int_arg2_int\n"
+
+		  	"bin_mul_arg1_int_arg2_frac:\n"
+		  	"mov r12, rbx\n"
+		  	"CAR r12\n"
+		  	"DATA r12\n";we will put in r12 second_numerator
+		  	"mov r10, rbx\n"
+		  	"CDR r10\n"
+		  	"DATA r10\n";we will put in r10 second_denominator
+		  	"mov r9,rax\n"
+		  	"DATA r9\n"
+		  	"MULT r9,r12\n"
+		  	
+		  	"mov rax,r9\n";now rax holds first_numerator*second_numerator
+
+		  	;rax holds new numerator
+		  	;r10 holds new denominator
+		  	"bin_mul_simplify_and_create_fraction:\n"
+		  	"mov r9,  rax\n"
+		  	"mov r8, r10\n"
+		  	"push r8\n"
+		  	"push r9\n"
+		  	"call simplify_fraction\n"
+		  	"add rsp, 16\n"
+		  	"jmp bin_mul_create_new_fraction\n"
+
+		  	"bin_mul_arg1_int_arg2_int:\n"
+		  	"DATA rbx\n" 
+		  	"DATA rax\n"
+		  	"mov r12, rax\n"     
+		  	"MULT rbx,r12\n"
+		  	"shl rbx, 4\n"
+		  	"or rbx, T_INTEGER\n"
+		  	"push rbx\n"
+		  	"mov rdi, 8\n"
+		  	"call malloc\n"
+		  	"pop rbx\n"
+		  	"mov [rax],rbx\n"
+		                        
+		  	"jmp bin_mul_finish\n"                     
+                    
+		  	"bin_mul_create_new_fraction:\n"
+		  	"cmp r8, 1\n"
+		  	"je bin_mul_create_new_int\n"
+
+		  	"shl r9, 4\n"
+		  	"or r9, T_INTEGER\n"		;r9 holds numerator in data structure
+		  	"shl r8, 4\n"
+		  	"or r8, T_INTEGER\n"		;r8 holds denominator in data structure
+		    
+		    "mov rdi, 8\n"
+		    "call malloc\n"
+		    "mov rbx, rax\n"
+		    "mov [rbx], r9\n"
+		    "push rbx\n"
+
+		    "mov rdi, 8\n"
+		    "call malloc\n"
+		    "pop rbx\n"
+		    "mov rcx, rax\n"
+		    "mov [rcx], r8\n"
+		    "push rbx\n"
+		    "push rcx\n"
+
+		    "mov rdi, 8\n"
+		    "call malloc\n" 
+		    "pop rcx\n"
+		    "pop rbx\n"
+                                               
+		  	"MAKE_LITERAL_FRACTION_WITH_REGS rax, rbx, rcx\n"
+		  	"jmp bin_mul_finish\n"
+		          
+		   	"bin_mul_create_new_int:\n"
+
+		   	"shl r9, 4\n"
+		  	"or r9, T_INTEGER\n"
+		  	"push r9\n"
+
+		  	"mov rdi, 8\n"
+		    "call malloc\n"
+		    "pop r9\n"
+		    "mov [rax], r9\n"
+          
+	        "bin_mul_finish:\n"
+	        "leave\n"
+	        "ret\n"
+	        "bin_mul_exit:\n")))
+
+(define cg-bin-div
+	(lambda ()
+		(string-append
+            "mov rdi, 16\n"
+            "call malloc\n"
+            "mov rbx, qword 0\n"
+            "MAKE_LITERAL_CLOSURE rax, rbx, bin_div_body\n"
+            "mov [bin_div], rax\n"
+            "jmp bin_div_exit\n"
+            
+            "bin_div_body:\n"
+        	"push rbp\n"
+      		"mov rbp, rsp\n"
+      		"mov rcx ,arg_count\n"
+      		"mov rax ,An(0)\n"                
+
+      		"cmp rcx, 2\n"         			; nil + 1 arguments?
+      		"jne bin_div_finish\n"
+     
+      		"mov rax ,qword [rax]\n"                     
+      		"mov rcx, rax\n"
+      		"TYPE rcx\n"
+      		"cmp rcx, T_INTEGER\n"
+      		"je bin_div_arg1_int_check_arg2\n"
+      
+      		"bin_div_arg1_frac_check_arg2:\n"
+      		"mov rbx, An(1)\n"
+       		"mov rbx, qword [rbx]\n"                    
+      		"mov rcx, rbx\n"
+      		"TYPE rcx\n"
+      		"cmp rcx, T_INTEGER\n"
+      		"je bin_div_arg1_frac_arg2_int\n"
+      
+      		"bin_div_arg1_frac_arg2_frac:\n"
+      		"mov rcx, rax\n"				
+      		"CAR rcx\n"
+      		"DATA rcx\n"					;rcx holds arg1 numerator	
+      		"mov r11, rax\n"      			;rdx keeps rax value
+      		"CDR r11\n"
+      		"DATA r11\n"
+      
+     		"mov r12, rbx\n"					
+      		"CAR r12\n"
+      		"DATA r12\n"					;r12 holds arg2 numerator
+      		"mov r10, rbx\n"				;r10 keeps r12 value
+      		"CDR r10\n"
+      		"DATA r10\n"
+      		"mov r9, r11\n"					;backup first denominator
+
+      		"MULT rcx, r10\n"				;now rcx holds arg1 numerator * arg2 denominator
+      		"MULT r11, r12\n"				;now r11 holds arg1 denominator * arg2 numerator
+      		"cmp r11, 0\n"
+		  	"jg bin_div_positive_int1\n"
+		  	"neg r11\n"
+		  	"neg rcx\n"
+		  	"bin_div_positive_int1:\n"
+      		"mov rax, rcx\n"	
+      		"mov r10, r11\n"					
+      		"jmp bin_div_simplify_and_create_fraction\n"                                             
+      		
+		  	"bin_div_arg1_int_check_arg2:\n"
+		  	"mov rbx, An(1)\n"
+		  	"mov rbx, qword [rbx]\n"                    
+		  	"mov rdx, rbx\n"
+		  	"TYPE rdx\n"
+		  	"cmp rdx, T_INTEGER\n"
+		  	"je bin_div_arg1_int_arg2_int\n"
+
+		  	"bin_div_arg1_int_arg2_frac:\n"
+		  	"mov r12, rbx\n"
+		  	"CAR r12\n"
+		  	"DATA r12\n";we will put in r12 second_numerator
+		  	"mov r10, rbx\n"
+		  	"CDR r10\n"
+		  	"DATA r10\n";we will put in r10 second_denominator
+		  	"mov r9,rax\n"
+		  	"DATA r9\n"
+		  	"MULT r9,r10\n"
+		  	"cmp r12, 0\n"
+		  	"jg bin_div_positive_int2\n"
+		  	"neg r12\n"
+		  	"neg r9\n"
+		  	"bin_div_positive_int2:\n"
+		  	"mov r10, r12\n"
+		  	"mov rax,r9\n"
+		  	"jmp bin_div_simplify_and_create_fraction\n"
+
+		  	"bin_div_arg1_frac_arg2_int:\n"
+		  	"mov r12, rax\n"
+		  	"CAR r12\n"
+		  	"DATA r12\n"
+		  	"mov r10, rax\n"
+		  	"CDR r10\n"
+		  	"DATA r10\n"
+		  	"mov r9,rbx\n"
+		  	"DATA r9\n"
+		  	"MULT r9,r10\n"
+		  	"cmp r9, 0\n"
+		  	"jg bin_div_positive_int3\n"
+		  	"neg r9\n"
+		  	"neg r12\n"
+		  	"bin_div_positive_int3:\n"
+		  	"mov rax,r9\n";now rax holds first_denominator*second_denominator
+		  	"mov r11, rax\n"
+		  	"mov rax, r12\n"
+		  	"mov r10, r11\n"
+
+
+		  	;rax holds new numerator
+		  	;r10 holds new denominator
+		  	"bin_div_simplify_and_create_fraction:\n"
+		  	"mov r9,  rax\n"
+		  	"mov r8, r10\n"
+		  	"push r8\n"
+		  	"push r9\n"
+		  	"call simplify_fraction\n"
+		  	"add rsp, 16\n"
+		  	"jmp bin_div_create_new_fraction\n"
+
+		  	"bin_div_arg1_int_arg2_int:\n"
+		  	"DATA rax\n"
+		  	"DATA rbx\n"
+		  	"mov r10, rbx\n"
+		  	"cmp r10, 0\n"
+		  	"jg bin_div_positive_int4\n"
+		  	"neg r10\n"
+		  	"neg rax\n"
+		  	"bin_div_positive_int4:\n" 
+		  	"jmp bin_div_simplify_and_create_fraction\n"
+		                                
+		  	"bin_div_create_new_fraction:\n"
+		  	"cmp r8, 1\n"
+		  	"je bin_div_create_new_int\n"
+
+		  	"shl r9, 4\n"
+		  	"or r9, T_INTEGER\n"		;r9 holds numerator in data structure
+		  	"shl r8, 4\n"
+		  	"or r8, T_INTEGER\n"		;r8 holds denominator in data structure
+		    
+		    "mov rdi, 8\n"
+		    "call malloc\n"
+		    "mov rbx, rax\n"
+		    "mov [rbx], r9\n"
+		    "push rbx\n"
+
+		    "mov rdi, 8\n"
+		    "call malloc\n"
+		    "pop rbx\n"
+		    "mov rcx, rax\n"
+		    "mov [rcx], r8\n"
+		    "push rbx\n"
+		    "push rcx\n"
+
+		    "mov rdi, 8\n"
+		    "call malloc\n" 
+		    "pop rcx\n"
+		    "pop rbx\n"
+                                               
+		  	"MAKE_LITERAL_FRACTION_WITH_REGS rax, rbx, rcx\n"
+		  	"jmp bin_div_finish\n"
+		          
+		   	"bin_div_create_new_int:\n"
+
+		   	"shl r9, 4\n"
+		  	"or r9, T_INTEGER\n"
+		  	"push r9\n"
+
+		  	"mov rdi, 8\n"
+		    "call malloc\n"
+		    "pop r9\n"
+		    "mov [rax], r9\n"
+          
+	        "bin_div_finish:\n"
+	        "leave\n"
+	        "ret\n"
+	        "bin_div_exit:\n")))
+
+(define cg-bin-less-than
+ 	(lambda()       
+		(string-append
+            "mov rdi, 16\n"
+            "call malloc\n"
+            "mov rbx, qword 0\n"
+            "MAKE_LITERAL_CLOSURE rax, rbx, bin_less_than_body\n"
+            "mov [bin_less_than], rax\n"
+            "jmp bin_less_than_exit\n"
+            
+            "bin_less_than_body:\n"
+        	"push rbp\n"
+			"mov rbp, rsp\n"         
+            "mov rbx, arg_count\n"
+	        "cmp rbx, 2\n" 
+	 		"jne bin_less_than_finish\n"
+
+	 		;"push const_2\n"
+	 		"push An(1)\n"
+	 		"push An(0)\n"
+	 		"push 2\n"
+	 		"push qword 0\n"
+	 		"call bin_minus_body\n"
+	 		"mov rax, [rax]\n"
+	 		"mov rbx, rax\n"
+	 		"TYPE rbx\n"
+	 		"cmp rbx, T_INTEGER\n"
+	 		"je check_sign\n"
+	 		"CAR rax\n"
+
+	 		"check_sign:\n"
+	 		"DATA rax\n"
+	 		"cmp rax, 0\n"
+	 		"jl bin_less_than_true\n"
+	        
+	        "mov rax, const_4\n"
+	        "jmp bin_less_than_finish\n"
+
+	        "bin_less_than_true:\n"
+	        "mov rax, const_3\n"
+
+	        "bin_less_than_finish:\n"
+	        "leave\n"
+	        "ret\n"
+	        "bin_less_than_exit:\n" )))
+
+(define cg-bin-greater-than
+ 	(lambda()       
+		(string-append
+            "mov rdi, 16\n"
+            "call malloc\n"
+            "mov rbx, qword 0\n"
+            "MAKE_LITERAL_CLOSURE rax, rbx, bin_greater_than_body\n"
+            "mov [bin_greater_than], rax\n"
+            "jmp bin_greater_than_exit\n"
+            
+            "bin_greater_than_body:\n"
+        	"push rbp\n"
+			"mov rbp, rsp\n"         
+            "mov rbx, arg_count\n"
+	        "cmp rbx, 2\n" 
+	 		"jne bin_greater_than_finish\n"
+
+	 		;"push const_2\n"
+	 		"push An(1)\n"
+	 		"push An(0)\n"
+	 		"push 2\n"
+	 		"push qword 0\n"
+	 		"call bin_minus_body\n"
+	 		"mov rax, [rax]\n"
+	 		"mov rbx, rax\n"
+	 		"TYPE rbx\n"
+	 		"cmp rbx, T_INTEGER\n"
+	 		"je bin_greater_than_check_sign\n"
+	 		"CAR rax\n"
+
+	 		"bin_greater_than_check_sign:\n"
+	 		"DATA rax\n"
+	 		"cmp rax, 0\n"
+	 		"jg bin_greater_than_true\n"
+	        
+	        "mov rax, const_4\n"
+	        "jmp bin_greater_than_finish\n"
+
+	        "bin_greater_than_true:\n"
+	        "mov rax, const_3\n"
+
+	        "bin_greater_than_finish:\n"
+	        "leave\n"
+	        "ret\n"
+	        "bin_greater_than_exit:\n" )))
+
+(define cg-char->integer
+	(lambda()
+		(string-append
+            "mov rdi, 16\n"
+            "call malloc\n"
+            "mov rbx, qword 0\n"
+            "MAKE_LITERAL_CLOSURE rax, rbx, char_to_integer_body\n"
+            "mov [char_to_integer], rax\n"
+            "jmp char_to_integer_exit\n"
+            
+            "char_to_integer_body:\n"
+        	"push rbp\n"
+			"mov rbp, rsp\n"         
+            "mov rbx, arg_count\n"
+	        "cmp rbx, 1\n" 
+	 		"jne char_to_integer_finish\n"
+
+	 		"mov rax, An(0)\n"
+	        "mov rax, [rax]\n"
+	        "mov rbx, rax\n"
+	        "TYPE rax\n"
+	        "cmp rax, T_CHAR\n"
+	        "jne char_to_integer_finish\n"
+
+	        "sub rbx, T_CHAR\n"
+	        "or rbx, T_INTEGER\n"
+
+	        "mov rdi,8\n"
+	        "call malloc\n"
+	        "mov qword [rax], rbx\n"
+
+	        "char_to_integer_finish:\n"
+	        "leave\n"
+	        "ret\n"
+	        "char_to_integer_exit:\n" )
+	))
+
+(define cg-integer->char
+	(lambda()
+		(string-append
+            "mov rdi, 16\n"
+            "call malloc\n"
+            "mov rbx, qword 0\n"
+            "MAKE_LITERAL_CLOSURE rax, rbx, integer_to_char_body\n"
+            "mov [integer_to_char], rax\n"
+            "jmp integer_to_char_exit\n"
+            
+            "integer_to_char_body:\n"
+        	"push rbp\n"
+			"mov rbp, rsp\n"         
+            "mov rbx, arg_count\n"
+	        "cmp rbx, 1\n" 
+	 		"jne integer_to_char_finish\n"
+
+	 		"mov rax, An(0)\n"
+	        "mov rax, [rax]\n"
+	        "mov rbx, rax\n"
+	        "TYPE rax\n"
+	        "cmp rax, T_INTEGER\n"
+	        "jne integer_to_char_finish\n"
+
+	        "sub rbx, T_INTEGER\n"
+	        "or rbx, T_CHAR\n"
+
+	        "mov rdi,8\n"
+	        "call malloc\n"
+	        "mov qword [rax], rbx\n"
+
+	        "integer_to_char_finish:\n"
+	        "leave\n"
+	        "ret\n"
+	        "integer_to_char_exit:\n" )
+	))
+
+(define cg-numerator
+	(lambda()
+		(string-append
+            "mov rdi, 16\n"
+            "call malloc\n"
+            "mov rbx, qword 0\n"
+            "MAKE_LITERAL_CLOSURE rax, rbx, numerator_body\n"
+            "mov [numerator], rax\n"
+            "jmp numerator_exit\n"
+            
+            "numerator_body:\n"
+        	"push rbp\n"
+			"mov rbp, rsp\n"         
+            "mov rbx, arg_count\n"
+	        "cmp rbx, 1\n" 
+	 		"jne numerator_finish\n"
+
+	 		"mov rax, An(0)\n"
+	        "mov rax, [rax]\n"
+	        "TYPE rax\n"
+	        "cmp rax, T_INTEGER\n"
+	        "je get_integer_numerator\n"
+	        "cmp rax, T_FRACTION\n"
+	        "jne numerator_finish\n"
+	        "mov rax, An(0)\n"
+	        "mov rax, [rax]\n"
+
+	        "DATA_UPPER rax\n"
+			"add rax, start_of_data\n"
+	        "jmp numerator_finish\n"
+
+	        "get_integer_numerator:\n"
+	        "mov rax, An(0)\n"
+
+	        "numerator_finish:\n"
+	        "leave\n"
+	        "ret\n"
+	        "numerator_exit:\n" )
+	))
+
+(define cg-denominator
+	(lambda()
+		(string-append
+            "mov rdi, 16\n"
+            "call malloc\n"
+            "mov rbx, qword 0\n"
+            "MAKE_LITERAL_CLOSURE rax, rbx, denominator_body\n"
+            "mov [denominator], rax\n"
+            "jmp denominator_exit\n"
+            
+            "denominator_body:\n"
+        	"push rbp\n"
+			"mov rbp, rsp\n"         
+            "mov rbx, arg_count\n"
+	        "cmp rbx, 1\n" 
+	 		"jne denominator_finish\n"
+
+	 		"mov rax, An(0)\n"
+	        "mov rax, [rax]\n"
+	        "TYPE rax\n"
+	        "cmp rax, T_INTEGER\n"
+	        "je get_integer_denominator\n"
+	        "cmp rax, T_FRACTION\n"
+	        "jne denominator_finish\n"
+	        "mov rax, An(0)\n"
+	        "mov rax, [rax]\n"
+	        "DATA_LOWER rax\n"
+			"add rax, start_of_data\n"
+	        "jmp denominator_finish\n"
+
+	        "get_integer_denominator:\n"
+	        "mov rbx, MAKE_LITERAL(T_INTEGER,1)\n"
+	        "mov rdi,8\n"
+	        "call malloc\n"    
+	        "mov qword [rax], rbx\n"
+
+	        "denominator_finish:\n"
+	        "leave\n"
+	        "ret\n"
+	        "denominator_exit:\n" )
+	))
+
+(define cg-remainder
+ 	(lambda()       
+		(string-append
+            "mov rdi, 16\n"
+            "call malloc\n"
+            "mov rbx, qword 0\n"
+            "MAKE_LITERAL_CLOSURE rax, rbx, remainder_body\n"
+            "mov [remainder], rax\n"
+            "jmp remainder_exit\n"
+            
+            "remainder_body:\n"
+        	"push rbp\n"
+			"mov rbp, rsp\n"         
+            "mov rbx, arg_count\n"
+	        "cmp rbx, 2\n" 
+	 		"jne remainder_finish\n"
+
+	 		"mov rax, An(0)\n"
+	 		"mov rax, [rax]\n"
+	 		"mov rcx, rax\n"
+	 		"mov rbx, An(1)\n"
+	 		"mov rbx, [rbx]\n"
+	 		"mov r12, rbx\n"
+	 		"TYPE rcx\n"
+	        "cmp rcx, T_INTEGER\n"
+	        "jne remainder_finish\n"
+	        "TYPE rbx\n"
+	        "cmp rbx, T_INTEGER\n"
+	        "jne remainder_finish\n"
+	        "DATA rax\n"
+	        "mov r8, rax\n"
+	        "DATA r12\n"
+	        "mov rdx, qword 0\n"
+	      
+	        "cmp r8, 0\n"
+	        "jge is_not_negative1\n"
+	        "neg rax\n"
+	        "is_not_negative1:\n"
+	        "mov rdx, qword 0\n"
+	        "idiv r12\n"
+	        "cmp r8, 0\n"
+	        "jge is_not_negative2\n"
+	        "neg rdx\n"
+	        "is_not_negative2:\n"
+
+	        "shl rdx, TYPE_BITS\n"
+	        "add rdx, T_INTEGER\n"
+	        "push rdx\n"
+	        "mov rdi, 8\n"
+	        "call malloc\n"
+	        "pop rdx\n"
+	        "mov [rax], rdx\n"
+	        
+	        "remainder_finish:\n"
+	        "leave\n"
+	        "ret\n"
+	        "remainder_exit:\n" )))
+
+(define cg-string-length
+	(lambda()
+		(string-append
+            "mov rdi, 16\n"
+            "call malloc\n"
+            "mov rbx, qword 0\n"
+            "MAKE_LITERAL_CLOSURE rax, rbx, string_length_body\n"
+            "mov [string_length], rax\n"
+            "jmp string_length_exit\n"
+            
+            "string_length_body:\n"
+        	"push rbp\n"
+			"mov rbp, rsp\n"         
+            "mov rbx, arg_count\n"
+	        "cmp rbx, 1\n" 
+	 		"jne string_length_finish\n"
+
+	 		"mov rax, An(0)\n"
+	        "mov rax, [rax]\n"
+	        "mov rbx,rax\n"
+	        "TYPE rax\n"
+	        "cmp rax, T_STRING\n"
+	        "jne string_length_finish\n"
+	        "STRING_LENGTH rbx\n"
+	        "shl rbx, TYPE_BITS\n"
+	        "add rbx, T_INTEGER\n"
+	        "mov rdi,8\n"
+	        "call malloc\n"
+	        "mov [rax], rbx\n"
+
+	        "string_length_finish:\n"
+	        "leave\n"
+	        "ret\n"
+	        "string_length_exit:\n" )
+	))
+
+(define cg-vector-length
+	(lambda()
+		(string-append
+            "mov rdi, 16\n"
+            "call malloc\n"
+            "mov rbx, qword 0\n"
+            "MAKE_LITERAL_CLOSURE rax, rbx, vector_length_body\n"
+            "mov [vector_length], rax\n"
+            "jmp vector_length_exit\n"
+            
+            "vector_length_body:\n"
+        	"push rbp\n"
+			"mov rbp, rsp\n"         
+            "mov rbx, arg_count\n"
+	        "cmp rbx, 1\n" 
+	 		"jne vector_length_finish\n"
+
+	 		"mov rax, An(0)\n"
+	        "mov rax, [rax]\n"
+	        "mov rbx,rax\n"
+	        "TYPE rax\n"
+	        "cmp rax, T_VECTOR\n"
+	        "jne vector_length_finish\n"
+	        "VECTOR_LENGTH rbx\n"
+	        "shl rbx, TYPE_BITS\n"
+	        "add rbx, T_INTEGER\n"
+	        "mov rdi,8\n"
+	        "call malloc\n"
+	        "mov [rax], rbx\n"
+
+	        "vector_length_finish:\n"
+	        "leave\n"
+	        "ret\n"
+	        "vector_length_exit:\n" )
+	))
+
+(define cg-string-ref
+	(lambda()
+		(string-append
+            "mov rdi, 16\n"
+            "call malloc\n"
+            "mov rbx, qword 0\n"
+            "MAKE_LITERAL_CLOSURE rax, rbx, string_ref_body\n"
+            "mov [string_ref], rax\n"
+            "jmp string_ref_exit\n"
+            
+            "string_ref_body:\n"
+        	"push rbp\n"
+			"mov rbp, rsp\n"         
+            "mov rbx, arg_count\n"
+	        "cmp rbx, 2\n" 
+	 		"jne string_ref_finish\n"
+
+	 		"mov rax, An(0)\n"
+	        "mov rax, [rax]\n"
+	        "mov rbx, rax\n"
+	        
+	        "mov rcx, An(1)\n"
+	        "mov rcx, [rcx]\n"
+	        "mov rdx, rcx\n"
+	        "DATA rdx\n"
+
+	        "TYPE rax\n"
+	        "cmp rax, T_STRING\n"
+	        "jne string_ref_finish\n"
+
+	        "TYPE rcx\n"
+	        "cmp rcx, T_INTEGER\n"
+	        "jne string_ref_finish\n"
+
+	        "STRING_REF cl, rbx, rdx\n"
+	        "shl rcx, TYPE_BITS\n"
+	        "add rcx, T_CHAR\n"
+	        "push rcx\n"
+	        "mov rdi,8\n"
+	        "call malloc\n"
+	        "pop rcx\n"
+	        "mov [rax], rcx\n"
+
+	        "string_ref_finish:\n"
+	        "leave\n"
+	        "ret\n"
+	        "string_ref_exit:\n" )))
+
+(define cg-vector-ref
+	(lambda()
+		(string-append
+            "mov rdi, 16\n"
+            "call malloc\n"
+            "mov rbx, qword 0\n"
+            "MAKE_LITERAL_CLOSURE rax, rbx, vector_ref_body\n"
+            "mov [vector_ref], rax\n"
+            "jmp vector_ref_exit\n"
+            
+            "vector_ref_body:\n"
+        	"push rbp\n"
+			"mov rbp, rsp\n"         
+            "mov rbx, arg_count\n"
+	        "cmp rbx, 2\n" 
+	 		"jne vector_ref_finish\n"
+
+	 		"mov rax, An(0)\n"
+	        "mov rax, [rax]\n"
+	        "mov rbx, rax\n"
+	        
+	        "mov rcx, An(1)\n"
+	        "mov rcx, [rcx]\n"
+	        "mov rdx, rcx\n"
+	        "DATA rdx\n"
+
+	        "TYPE rax\n"
+	        "cmp rax, T_VECTOR\n"
+	        "jne vector_ref_finish\n"
+
+	        "TYPE rcx\n"
+	        "cmp rcx, T_INTEGER\n"
+	        "jne vector_ref_finish\n"
+
+	        "VECTOR_REF rcx, rbx, rdx\n"
+	        "push rcx\n"
+	        "mov rdi,8\n"
+	        "call malloc\n"
+	        "pop rcx\n"
+	        "mov [rax], rcx\n"
+
+	        "vector_ref_finish:\n"
+	        "leave\n"
+	        "ret\n"
+	        "vector_ref_exit:\n" )))
+
+(define cg-string-set
+	(lambda()
+		(string-append
+            "mov rdi, 16\n"
+            "call malloc\n"
+            "mov rbx, qword 0\n"
+            "MAKE_LITERAL_CLOSURE rax, rbx, string_set_body\n"
+            "mov [string_set], rax\n"
+            "jmp string_set_exit\n"
+            
+            "string_set_body:\n"
+        	"push rbp\n"
+			"mov rbp, rsp\n"         
+            "mov rbx, arg_count\n"
+	        "cmp rbx, 3\n" 
+	 		"jne string_set_finish\n"
+
+	 		"mov rax, An(0)\n" ;string	        
+	        
+	        "mov rax, [rax]\n"
+	        "mov rbx, rax\n" 
+
+	        "mov r11, An(1)\n" ;index
+	        "mov r11, [r11]\n"
+	        "mov rdx, r11\n"
+	        "DATA rdx\n"
+
+	       	"mov r12, An(2)\n" ;char
+	        "mov r12, [r12]\n"
+	        "mov rcx, r12\n"
+	        "DATA rcx\n"
+
+	        "TYPE rax\n"
+	        "cmp rax, T_STRING\n"
+	        "jne string_set_finish\n"
+
+	        "TYPE r11\n"
+	        "cmp r11, T_INTEGER\n"
+	        "jne string_set_finish\n"
+
+	       	"TYPE r12\n"
+	        "cmp r12, T_CHAR\n"
+	        "jne string_set_finish\n"
+
+	        ;rbx=string, rdx=index, rcx=char
+
+	        "mov r10, rbx\n"
+	        "STRING_ELEMENTS rbx\n"
+			"add rbx, rdx\n"
+			"mov byte [rbx], cl\n"
+
+	        "mov rax, const_1\n"
+
+	        "string_set_finish:\n"
+	        "leave\n"
+	        "ret\n"
+	        "string_set_exit:\n" )))
+
+(define cg-vector-set
+	(lambda()
+		(string-append
+            "mov rdi, 16\n"
+            "call malloc\n"
+            "mov rbx, qword 0\n"
+            "MAKE_LITERAL_CLOSURE rax, rbx, vector_set_body\n"
+            "mov [vector_set], rax\n"
+            "jmp vector_set_exit\n"
+            
+            "vector_set_body:\n"
+        	"push rbp\n"
+			"mov rbp, rsp\n"         
+            "mov rbx, arg_count\n"
+	        "cmp rbx, 3\n" 
+	 		"jne vector_set_finish\n"
+
+	 		"mov rax, An(0)\n" ;vector	        
+	        "mov rax, [rax]\n"
+	        "mov rbx, rax\n" 
+
+	        "mov r11, An(1)\n" ;index
+	        "mov r11, [r11]\n"
+	        "mov rdx, r11\n"
+	        "DATA rdx\n"
+
+	       	"mov rcx, An(2)\n" ;address of item
+
+	        "TYPE rax\n"
+	        "cmp rax, T_VECTOR\n"
+	        "jne vector_set_finish\n"
+
+	        "TYPE r11\n"
+	        "cmp r11, T_INTEGER\n"
+	        "jne vector_set_finish\n"
+
+	        ;rbx=vector, rdx=index, rcx=item
+
+	        "mov r10, rbx\n"
+	        "VECTOR_ELEMENTS r10\n"
+	        "mov [r10 + rdx*8], rcx\n"
+
+	        "mov rax, const_1\n"
+
+	        "vector_set_finish:\n"
+	        "leave\n"
+	        "ret\n"
+	        "vector_set_exit:\n" )))
+
+(define cg-make-string
+	(lambda()
+		(string-append
+            "mov rdi, 16\n"
+            "call malloc\n"
+            "mov rbx, qword 0\n"
+            "MAKE_LITERAL_CLOSURE rax, rbx, make_string_body\n"
+            "mov [make_string], rax\n"
+            "jmp make_string_exit\n"
+            
+            "make_string_body:\n"
+        	"push rbp\n"
+			"mov rbp, rsp\n"
+			"mov rdx, qword 0\n" ;initialize char with 0         
+            "mov r8, arg_count\n"
+	        "cmp r8, 2\n"
+	 		"jg make_string_finish\n"
+
+	 		"mov rax, An(0)\n" ;length of string	        
+	        "mov rax, [rax]\n"
+	        "mov rbx, rax\n"
+	        "DATA rbx\n" 
+
+	        "TYPE rax\n"
+	        "cmp rax, T_INTEGER\n"
+	        "jne make_string_finish\n"
+
+	        "cmp r8, 1\n"
+	        "je start_creating_string\n"
+
+	        "mov rcx, An(1)\n" ;char
+	        "mov rcx, [rcx]\n"
+	        "mov rdx, rcx\n"
+	        "DATA rdx\n"
+
+	        "TYPE rcx\n"
+	        "cmp rcx, T_CHAR\n"
+	        "jne make_string_finish\n"
+
+	        "start_creating_string:\n"
+
+	        "push rbx\n"
+	        "push rdx\n"
+	        "mov rdi, rbx\n"
+	        "call malloc\n"
+	        "pop rdx\n"
+	        "pop rbx\n"
+
+ 
+	        ;rax= pointer to address of rbx bytes, rbx=length of string, rdx=char
+	        "mov r12, 0\n" ;counter
+
+	        "for_create_string:\n"
+	        "cmp r12, rbx\n"
+	        "je end_of_create_string\n"
+	        "mov byte [rax+r12], dl\n"
+	        "inc r12\n"
+	        "jmp for_create_string\n"
+	        "end_of_create_string:\n"
+
+	        "mov rcx, rax\n"
+
+	        "MAKE_LITERAL_STRING_WITH_REGS rcx, rbx\n" ;at the end of macro, rax is a literal string
+	        "mov rcx, rax\n"
+	        "push rcx\n"
+	        "mov rdi, 8\n"
+	        "call malloc\n"
+	        "pop rcx\n"
+
+	        "mov [rax], rcx\n"
+
+	        "make_string_finish:\n"
+	        "leave\n"
+	        "ret\n"
+	        "make_string_exit:\n" )))
+
+(define cg-make-vector
+	(lambda()
+		(string-append
+            "mov rdi, 16\n"
+            "call malloc\n"
+            "mov rbx, qword 0\n"
+            "MAKE_LITERAL_CLOSURE rax, rbx, make_vector_body\n"
+            "mov [make_vector], rax\n"
+            "jmp make_vector_exit\n"
+            
+            "make_vector_body:\n"
+        	"push rbp\n"
+			"mov rbp, rsp\n"  
+			;initialize item with 0
+			"mov rdi, 8\n"
+			"call malloc\n"
+			"mov rdx, 0\n"
+			"shl rdx, TYPE_BITS\n"
+	        "add rdx, T_INTEGER\n"       
+            "mov rbx, arg_count\n"
+            "mov [rax], rdx\n" 
+            "mov rdx, rax\n" ;now rdx conatins integer 0
+	        "cmp rbx, 2\n" 
+	 		"jg make_vector_finish\n"
+
+	 		"mov rax, An(0)\n" ;length of vector	        
+	        "mov rax, [rax]\n"
+	        "mov rbx, rax\n"
+	        "DATA rbx\n" 
+
+	        "TYPE rax\n"
+	        "cmp rax, T_INTEGER\n"
+	        "jne make_vector_finish\n"
+
+	        "mov r8, arg_count\n"
+	        "cmp r8, 1\n"
+	        "je start_creating_vector\n"
+	        "mov rdx, An(1)\n" ; address of item
+
+	        "start_creating_vector:\n"
+
+	        "push rbx\n"
+	        "push rdx\n"
+	        "shl rbx, 3\n"
+	        "mov rdi, rbx\n"
+	        "call malloc\n"
+	        "pop rdx\n"
+	        "pop rbx\n"
+ 
+	        ;rax= pointer to address of rbx*8 bytes, rbx=length of vector, rdx=address of item
+	        "mov r12, 0\n" ;counter
+
+	        "for_create_vector:\n"
+	        "cmp r12, rbx\n"
+	        "je end_of_create_vector\n"
+	        "mov qword [rax+r12*8], rdx\n"
+	        "inc r12\n"
+	        "jmp for_create_vector\n"
+	        "end_of_create_vector:\n"
+
+	        "mov rcx, rax\n"
+	        "shl rbx, 3\n"
+	        "MAKE_LITERAL_VECTOR_WITH_REGS rcx, rbx\n" ;at the end of macro, rax is a literal vector
+	        "mov rcx, rax\n"
+	        "push rcx\n"
+	        "mov rdi, 8\n"
+	        "call malloc\n"
+	        "pop rcx\n"
+	        "mov [rax], rcx\n"
+
+	        "make_vector_finish:\n"
+	        "leave\n"
+	        "ret\n"
+	        "make_vector_exit:\n" )))
+
+(define cg-vector
+	(lambda()
+		(string-append
+            "mov rdi, 16\n"
+            "call malloc\n"
+            "mov rbx, qword 0\n"
+            "MAKE_LITERAL_CLOSURE rax, rbx, custom_vector_body\n"
+            "mov [custom_vector], rax\n"
+            "jmp custom_vector_exit\n"
+            
+            "custom_vector_body:\n"
+        	"push rbp\n"
+			"mov rbp, rsp\n"         
+            "mov rbx, arg_count\n"
+
+	        "push rbx\n"
+	        "shl rbx, 3\n"
+	        "mov rdi, rbx\n"
+	        "call malloc\n"
+	        "pop rbx\n"
+ 
+	        ;rax= pointer to address of rbx*8 bytes, rbx=length of vector
+	        "mov r12, 0\n" ;counter
+	        "for_vector:\n"
+	        "cmp r12, rbx\n"
+	        "je end_of_vector\n"
+
+	        "mov rdx, An(r12)\n" 
+	        "mov qword [rax+r12*8], rdx\n"
+	        "inc r12\n"
+	        "jmp for_vector\n"
+	        "end_of_vector:\n"
+
+	        "mov rcx, rax\n"
+	        "shl rbx, 3\n"
+	        "MAKE_LITERAL_VECTOR_WITH_REGS rcx, rbx\n" ;at the end of macro, rax is a literal vector
+	        "mov rcx, rax\n"
+	        "push rcx\n"
+	        "mov rdi, 8\n"
+	        "call malloc\n"
+	        "pop rcx\n"
+	        "mov [rax], rcx\n"
+
+	        "custom_vector_finish:\n"
+	        "leave\n"
+	        "ret\n"
+	        "custom_vector_exit:\n" )))
+
+(define cg-apply
+ 	(lambda()       
+		(string-append
+            "mov rdi, 16\n"
+            "call malloc\n"
+            "mov rbx, qword 0\n"
+            "MAKE_LITERAL_CLOSURE rax, rbx, apply_body\n"
+            "mov [apply], rax\n"
+            "jmp apply_exit\n"
+            
+            "apply_body:\n"
+    		"push rbp\n"
+            "mov rbp, rsp\n"
+	        "mov rax, An(0)\n"				;closure
+	        "mov rax, qword [rax]\n"
+	        "mov r12, qword [rbp]\n" 		;old rbp
+	        "mov r11,qword [rbp+8]\n" 		;ret addr
+	        "mov r10, rbp\n"
+	        "add r10, 5*8\n"
+	        
+	        "mov rbx, rax\n" 
+	        "TYPE rbx\n"
+	        "cmp rbx, T_CLOSURE\n"
+	        "jne apply_finish\n"
+	         
+	        "mov rcx, An(1)\n"
+	        "mov rcx, qword [rcx]\n"
+	        "mov rbx, rcx\n"
+	        "TYPE rbx\n"
+	        "cmp rbx, T_PAIR\n"
+	        "je apply_start\n"
+
+	        "cmp rbx, T_NIL\n"
+	        "jne apply_finish\n"
+
+	        "apply_start:\n"
+	        "mov rsi, 0\n"
+
+		    "apply_calculate_list_length:\n"
+		    "cmp rbx, T_NIL\n"
+		    "je apply_calculate_list_length_done\n"
+		    "CDR rcx\n"
+		    "mov rbx, rcx\n"
+		    "TYPE rbx\n"
+		    "inc rsi\n"
+		    "jmp apply_calculate_list_length\n"
+
+	        "apply_calculate_list_length_done:\n"
+	        "shl rsi, 3\n"
+	        "sub r10, rsi\n"
+	        "shr rsi, 3\n"
+	        
+	        "mov rdi, 0\n"
+	        "mov rcx, An(1)\n"  			 
+	        "mov rcx, qword [rcx]\n"
+
+	        "apply_loop:\n"
+
+	        "cmp rdi, rsi\n"
+	        "je apply_loop_exit\n"
+	        "mov rbx, rcx\n"
+	        "DATA_UPPER rbx\n"
+			"add rbx, start_of_data\n"    
+	        "mov qword [r10 + 8*rdi], rbx\n"
+	        "CDR rcx\n"
+	        "inc rdi\n"
+	        "jmp apply_loop\n"
+	        
+	        "apply_loop_exit:\n"
+
+	        "sub r10, 8\n"
+	        "mov qword [r10],rsi\n"
+	        "sub r10, 8\n"
+	        "mov rbx, rax\n"
+	        "CLOSURE_ENV rbx\n"
+	        "mov qword [r10], rbx\n"
+	        "sub r10, 8\n"
+	        "mov qword [r10], r11\n"
+	        "mov rsp, r10\n"	        
+	        "mov rbp, r12\n"
+	        "mov rbx, rax\n"
+	        "TYPE rbx\n"
+	        
+	        "cmp rbx, T_CLOSURE\n"
+	        "jne apply_finish\n"
+	        "CLOSURE_CODE rax\n"
+	        "jmp rax\n"
+	        "apply_finish:\n"
+	        "leave\n"
+	        "ret\n"
+	        "apply_exit:\n" )))
+
+
+(define cg-symbol->string
+	(lambda ()
+		(string-append
+			"mov rdi, 16\n"
+            "call malloc\n"
+            "mov rbx, qword 0\n"
+            "MAKE_LITERAL_CLOSURE rax, rbx, symbol_to_string_body\n"
+            "mov [symbol_to_string], rax\n"
+            "jmp symbol_to_string_exit\n"
+            
+            "symbol_to_string_body:\n"
+    		"push rbp\n"
+            "mov rbp, rsp\n"
+            "mov rax, An(0)\n"
+            "mov rax, [rax]\n"
+            "DATA rax\n"
+			"add rax , start_of_data\n"
+	        "symbol_to_string_finish:\n"
+	        "leave\n"
+	        "ret\n"
+	        "symbol_to_string_exit:\n" )))
+
+
+(define newLine
+  (list->string '(#\newline)))
+
+(define tab
+(list->string '(#\tab)))
+
+(define cg-string->symbol
+	(lambda ()
+	  (string-append
+	   tab "mov rdi, 16" newLine
+	   tab "call malloc" newLine
+	   tab "mov rbx, qword 0" newLine
+	   tab "MAKE_LITERAL_CLOSURE rax, rbx, string_to_symbol_body" newLine
+	   tab "mov qword [string_to_symbol], rax" newLine
+	   tab "jmp string_to_symbol_exit" newLine
+	   newLine
+	    "string_to_symbol_body:" newLine
+	   tab "push rbp" newLine
+	   tab "mov rbp, rsp" newLine
+	   tab "mov r11, An(0)" newLine ;r11= pointer to arg
+	   
+	   tab "mov r12, [symbol_table]" newLine		
+	   tab "cmp r12, const_2" newLine
+	   tab "je string_to_symbol_create_symbol" newLine
+    		
+	   "string_to_symbol_loop:" newLine
+	   tab "mov r10, r12" newLine
+	   tab "mov r10, [r10]" newLine
+	   tab "DATA_UPPER r10" newLine
+	   tab "add r10 , start_of_data" newLine
+	   tab "mov r10, [r10]" newLine
+	   tab "DATA r10" newLine
+	   tab "add r10 , start_of_data" newLine
+	   tab "STRING_COMPARE r10, r11" newLine
+	   tab "cmp rax, const_3" newLine 
+	   tab "je string_to_symbol_found" newLine
+	   newLine
+	   tab "mov r12, [r12]" newLine
+	   tab "DATA_LOWER r12" newLine
+	   tab "add r12, start_of_data" newLine
+	   tab "cmp r12, const_2" newLine
+	   tab "je string_to_symbol_create_symbol" newLine
+	   newLine
+	   tab "jmp string_to_symbol_loop" newLine
+	   newLine         
+	   "string_to_symbol_found:" newLine
+	   tab "mov r12, [r12]" newLine
+	   tab "DATA_UPPER r12" newLine
+	   tab "add r12, start_of_data" newLine
+	   tab "mov rax, r12" newLine
+	   tab "jmp string_to_symbol_finish" newLine
+	   newLine
+	   tab "string_to_symbol_create_symbol:" newLine
+	   tab "push r11" newLine
+	   tab "mov rdi,8" newLine
+	   tab "call malloc" newLine
+	   tab "pop r11" newLine
+	   tab "MAKE_MALLOC_LITERAL_SYMBOL rax , r11" newLine
+	   tab "mov r11, rax" newLine
+	   tab "mov r13, r11" newLine
+	   tab "mov r14, [symbol_table]" newLine
+	   newLine
+	   tab "push r11" newLine
+	   tab "push r14" newLine
+	   tab "mov rdi, 8" newLine
+	   tab "call malloc" newLine
+	   tab "pop r14" newLine
+	   tab "pop r11" newLine
+	   tab "MAKE_MALLOC_LITERAL_PAIR rax, r11 ,r14" newLine
+	   tab "mov [symbol_table],rax"  newLine
+	   tab "mov rax, r13" newLine
+	   newLine
+	   "string_to_symbol_finish:" newLine
+	   tab "leave" newLine
+	   tab "ret" newLine
+	   "string_to_symbol_exit:" newLine)))
+
+(define pipeline
+	(lambda (s)
+		((star <sexpr>) s 
+			(lambda (m r)
+				(map (lambda (e)
+						(annotate-tc
+							(pe->lex-pe
+								(box-set
+									(remove-applic-lambda-nil
+										(parse e))))))
+					  m))
+	   		(lambda (f) 'fail))))
+
+(define file->list
+	(lambda (input-file)
+		(let ((in-port (open-input-file input-file)))
+			(letrec ((run (lambda ()
+							(let ((ch (read-char in-port)))
+								(if (eof-object? ch)
+									(begin (close-input-port in-port) '())
+									(cons ch (run)))))))
+				(run)))))
+
+(define string->file
+	(lambda (out-file str)
+		(if (file-exists? out-file) (delete-file out-file))
+		(let ((out-port (open-output-file out-file)))
+			(letrec ((run
+				(lambda (lst)
+					(if (null? lst) (close-output-port out-port)
+								(begin
+									(write-char (car lst) out-port)
+									(run (cdr lst)))))))
+				(run (string->list str))))))
+
+
+(define compile-scheme-file
+	(lambda (source-file target-file)
+		(let* ((parsed-exp-list 	(pipeline (append_build_in_funcs (file->list source-file))))
+			   (epilogue 			"push qword [rax]\ncall write_sob_if_not_void\nadd rsp, 1*8\n"))
+			   (create-c-table parsed-exp-list)
+
+			   ;;(display (format "c-table ~a\n" c-table))
+
+
+			   (create-global-var-table parsed-exp-list)
+
+			   (string->file
+					target-file
+					(string-append
+						"%include \"project/scheme.s\"\nsection .data\nstart_of_data:\n"
+						(get-const-string)
+						(get-fvar-string)
+						(cg-symbol-table c-table 0 (count-symbols))
+						"\nsection .text\nmain:\n"
+						"push 0\n"
+						"push 0\n"
+						"push exit_compilation\n"
+						"push rbp\n"
+						"mov rbp, rsp\n"
+						(code-cg-library-functions)
+						(fold-left (lambda(acc pe) 
+	                                    (string-append acc (code_gen pe) epilogue))
+									""
+								parsed-exp-list)
+						"exit_compilation:\n"
+						"leave\n"
+						"mov rax, 0\n"
+						"call exit\n"
+						)))))
+
+
+
diff --git a/Makefile b/Makefile
old mode 100644
new mode 100755
index e69de29..d4fe475
--- a/Makefile
+++ b/Makefile
@@ -0,0 +1,9 @@
+loadVar:= (load "project/Compiler.scm")
+
+loadVarInternal:= (load "Compiler.scm")
+
+%:
+	echo '$(loadVar) (compile-scheme-file "$(MAKECMDGOALS).scm" "$(MAKECMDGOALS).s")' | scheme -q
+	nasm -f elf64 $(MAKECMDGOALS).s -o $(MAKECMDGOALS).o
+	gcc -m64 -Wall -o $(MAKECMDGOALS) $(MAKECMDGOALS).o
+
diff --git a/pattern-matcher.scm b/pattern-matcher.scm
new file mode 100755
index 0000000..3fed604
--- /dev/null
+++ b/pattern-matcher.scm
@@ -0,0 +1,80 @@
+;;; pattern-matcher.scm
+;;; The pattern-matching package
+;;;
+;;; Programmer: Mayer Goldberg, 2016
+
+(define match
+  (letrec ((match
+	    (lambda (pat e ret-dict ret-no-match)
+	      (cond ((and (pair? pat) (pair? e))
+		     (match (car pat) (car e)
+			    (lambda (car-dict)
+			      (match (cdr pat) (cdr e)
+				     (lambda (cdr-dict)
+				       (ret-dict
+					(append car-dict cdr-dict)))
+				     ret-no-match))
+			    ret-no-match))
+		    ((and (vector? pat) (vector? e)
+			  (= (vector-length pat)
+			     (vector-length e)))
+		     (match
+		      (vector->list pat)
+		      (vector->list e)
+		      ret-dict
+		      ret-no-match))
+		    ;; match with unification
+		    ((procedure? pat)
+		     (if (pat e)
+			 (ret-dict `(,e))
+			 (ret-no-match)))
+		    ((or (and (char? pat) (char? e) (char=? pat e))
+			 (and (string? pat)
+			      (string? e)
+			      (string=? pat e))
+			 (and (symbol? pat) (symbol? e) (eq? pat e))
+			 (and (number? pat) (number? e) (= pat e))
+			 (eq? pat e))
+		     (ret-dict '()))
+		    (else (ret-no-match))))))
+    (lambda (pat e ret-match ret-no-match)
+      (match pat e
+	     (lambda (dict) (apply ret-match dict))
+	     ret-no-match))))
+
+(define ?
+  (lambda (name . guards)
+    (lambda (e)
+      (andmap
+       (lambda (pred?)
+	 (pred? e))
+       guards))))
+
+;;; composing patterns
+
+(define pattern-rule
+  (lambda (pat handler)
+    (lambda (e failure)
+      (match pat e handler failure))))
+
+(define compose-patterns
+  (letrec ((match-nothing
+	    (lambda (e failure)
+	      (failure)))
+	   (loop
+	    (lambda (s)
+	      (if (null? s)
+		  match-nothing
+		  (let ((match-rest
+			 (loop (cdr s)))
+			(match-first (car s)))
+		    (lambda (e failure)
+		      (match-first e
+		       (lambda ()
+			 (match-rest e failure)))))))))
+    (lambda patterns
+      (loop patterns))))
+
+;;; end of input
+
+
diff --git a/pc.scm b/pc.scm
new file mode 100755
index 0000000..2dfd912
--- /dev/null
+++ b/pc.scm
@@ -0,0 +1,441 @@
+;;; pc.scm
+;;; A simple implementation of parsing combinators
+;;;
+;;; Programmer: Mayer Goldberg, 2017
+
+(define with (lambda (s f) (apply f s)))
+
+(define *marker-length* 8)
+
+(define <end-of-input>
+  (lambda (s ret-match ret-none)
+    (if (null? s)
+	(ret-match '() '())
+	(ret-none '()))))
+
+(define const
+  (lambda (pred?)
+    (lambda (s ret-match ret-none)
+      (cond ((null? s) (ret-none '()))
+	    ((pred? (car s)) (ret-match (car s) (cdr s)))
+	    (else (ret-none '()))))))
+
+(define <epsilon>
+  (lambda (s ret-match ret-none)
+    (ret-match '() s)))
+
+(define <fail>
+  (lambda (s ret-match ret-none)
+    (ret-none '())))
+
+(define caten
+  (let ((binary-caten
+	 (lambda (<p1> <p2>)
+	   (lambda (s ret-match ret-none)
+	     (<p1> s
+		 (lambda (e1 s)
+		   (<p2> s
+		       (lambda (e2 s)
+			 (ret-match (cons e1 e2) s))
+		       ret-none))
+		 ret-none)))))
+    (lambda ps
+      (fold-right binary-caten <epsilon> ps))))
+
+(define disj
+  (let ((binary-disj
+	 (lambda (<p1> <p2>)
+	   (lambda (s ret-match ret-none)
+	     (<p1> s
+		 ret-match
+		 (lambda (w)
+		   (<p2> s
+		       ret-match
+		       ret-none)))))))
+    (lambda ps
+      (fold-right binary-disj <fail> ps))))
+
+(define delayed
+  (lambda (thunk)
+    (lambda (s ret-match ret-none)
+      ((thunk) s ret-match ret-none))))
+
+(define star
+  (lambda (p)
+    (disj (pack-with (caten p (delayed (lambda () (star p))))
+		     cons)
+	  <epsilon>)))
+
+(define plus
+  (lambda (p)
+    (pack-with (caten p (star p))
+	       cons)))
+
+(define times
+  (lambda (<p> n)
+    (if (zero? n)
+	<epsilon>
+	(pack-with
+	 (caten <p> (times <p> (- n 1)))
+	 cons))))
+
+(define at-least
+  (lambda (<p> n)
+    (new (*parser <p>)
+	 (*times n)
+	 (*parser <p>)
+	 *star
+	 (*caten 2)
+	 (*pack-with
+	  (lambda (e^4 e^*)
+	    `(,@e^4 ,@e^*)))
+	 done)))
+
+(define pack
+  (lambda (p f)
+    (lambda (s ret-match ret-none)
+      (p s (lambda (e s) (ret-match (f e) s)) ret-none))))
+
+(define pack-with
+  (lambda (p f)
+    (lambda (s ret-match ret-none)
+      (p s (lambda (e s) (ret-match (apply f e) s)) ret-none))))
+
+(define diff
+  (lambda (<p1> <p2>)
+    (lambda (s ret-match ret-none)
+      (<p1> s
+	  (lambda (e w)
+	    (<p2> s (lambda _ (ret-none '()))
+		(lambda (w1) (ret-match e w))))
+	  ret-none))))
+
+(define maybe
+  (lambda (p)
+    (lambda (s ret-match ret-none)
+      (p s
+	 (lambda (e s) (ret-match `(#t ,e) s))
+	 (lambda (w) (ret-match `(#f #f) s))))))
+
+(define only-if
+  (lambda (p pred?)
+    (lambda (s ret-match ret-none)
+      (p s
+	 (lambda (e s)
+	   (if (pred? e)
+	       (ret-match e s)
+	       (ret-none '())))
+	 ret-none))))
+
+(define otherwise
+  (lambda (p message)
+    (lambda (s ret-match ret-none)
+      (p s
+	 ret-match
+	 (let ((marker
+		(format "-->[~a]"
+		  (list->string
+		   (list-head s *marker-length*)))))
+	   (lambda (w) (ret-none `(,@w ,message ,marker))))))))
+
+;;;
+
+(define ^char
+  (lambda (char=?)
+    (lambda (character)
+      (const
+       (lambda (ch)
+	 (char=? ch character))))))
+
+(define char (^char char=?))
+
+(define char-ci (^char char-ci=?))
+
+(define ^word
+  (lambda (char)
+    (lambda (word)
+      (apply caten (map char (string->list word))))))
+
+(define word (^word char))
+
+(define word-ci (^word char-ci))
+
+(define ^word-suffixes
+  (lambda (char)
+    (letrec ((loop
+	      (lambda (s)
+		(if (null? s)
+		    <epsilon>
+		    (maybe
+		     (caten (char (car s))
+			    (loop (cdr s))))))))
+      (lambda (suffix)
+	(loop (string->list suffix))))))
+
+(define word-suffixes (^word-suffixes char))
+
+(define word-suffixes-ci (^word-suffixes char-ci))
+
+(define ^word+suffixes
+  (lambda (word-suffixes)
+    (lambda (prefix suffix)
+      (caten (word prefix)
+	     (word-suffixes suffix)))))
+
+(define word+suffixes (^word+suffixes word-suffixes))
+
+(define word+suffixes-ci (^word+suffixes word-suffixes-ci))
+
+(define ^one-of
+  (lambda (char)
+    (lambda (word)
+      (apply disj (map char (string->list word))))))
+
+(define one-of (^one-of char))
+
+(define one-of-ci (^one-of char-ci))
+
+(define ^range
+  (lambda (char<=?)
+    (lambda (char-from char-to)
+      (const
+       (lambda (ch)
+	 (and (char<=? char-from ch)
+	      (char<=? ch char-to)))))))
+
+(define range (^range char<=?))
+
+(define range-ci (^range char-ci<=?))
+
+(define <any-char> (const (lambda (ch) #t)))
+
+(define <any> <any-char>)
+
+;;; <expr> {<sep> <expr>}*
+(define ^<separated-exprs>
+  (lambda (<expr> <sep>)
+    (new (*parser <expr>)
+	 
+	 (*parser <sep>)
+	 (*parser <expr>)
+	 (*caten 2)
+	 (*pack-with (lambda (_sep expr) expr))
+	 *star
+	 
+	 (*caten 2)
+	 (*pack-with cons)
+	 done)))
+
+;;;
+
+(define continue
+  (lambda (ds cs)
+    (with cs
+      (lambda (c . cs)
+	(c ds cs)))))
+
+(define new
+  (lambda cs
+    (continue '() cs)))
+
+(define done
+  (lambda (ds cs)
+    (with ds
+      (lambda (parser . ds)
+	(if (null? ds)
+	    parser
+	    (error 'done
+		   (format "The parser stack still contains ~a parsers!"
+		     (length ds))))))))
+
+(define *parser
+  (lambda (p)
+    (lambda (ds cs)
+      (continue `(,p . ,ds) cs))))
+
+(define unary
+  (lambda (f-unary)
+    (lambda (ds cs)
+      (with ds
+	(lambda (d . ds)
+	  (continue `(,(f-unary d) . ,ds) cs))))))
+
+(define *delayed
+  (lambda (thunk)
+    (lambda (ds cs)
+      (continue `(,(delayed thunk) . ,ds) cs))))
+
+(define binary
+  (lambda (f-binary)
+    (lambda (ds cs)
+      (with ds
+	(lambda (d2 d1 . ds)
+	  (continue `(,(f-binary d1 d2) . ,ds) cs))))))
+
+(define *dup
+  (lambda (ds cs)
+    (with ds
+      (lambda (d1 . ds)
+	(continue `(,d1 ,d1 . ,ds) cs)))))
+
+(define *swap
+  (lambda (ds cs)
+    (with ds
+      (lambda (d1 d2 . ds)
+	(continue `(,d2 ,d1 . ,ds) cs)))))
+
+(define *star (unary star))
+
+(define *plus (unary plus))
+
+(define *diff (binary diff))
+
+(define *pack (lambda (f) (unary (lambda (p) (pack p f)))))
+
+(define *pack-with (lambda (f) (unary (lambda (p) (pack-with p f)))))
+
+(define *only-if (lambda (pred?) (unary (lambda (p) (only-if p pred?)))))
+
+(define split-list
+  (lambda (s n ret-s1+s2)
+    (if (zero? n)
+	(ret-s1+s2 '() s)
+	(split-list (cdr s) (- n 1)
+		    (lambda (s1 s2)
+		      (ret-s1+s2 (cons (car s) s1) s2))))))
+
+(define nary
+  (lambda (f-n-ary n)
+    (lambda (ds cs)
+      (split-list ds n
+       (lambda (sgra ds)
+	 (continue
+	  `(,(apply f-n-ary (reverse sgra)) . ,ds) cs))))))
+
+(define *caten (lambda (n) (nary caten n)))
+
+(define *disj (lambda (n) (nary disj n)))
+
+(define *maybe (unary maybe))
+
+(define *otherwise
+  (lambda (string)
+    (unary
+     (lambda (p)
+       (otherwise p string)))))
+
+(define *times
+  (lambda (n)
+    (unary
+     (lambda (<p>)
+       (times <p> n)))))
+
+(define *at-least
+  (lambda (n)
+    (unary
+     (lambda (<p>)
+       (at-least <p> n)))))
+
+(define followed-by
+  (lambda (<p1> <p2>)
+    (lambda (s ret-match+rest ret-none)
+      (<p1> s
+	    (lambda (e s)
+	      (<p2> s
+		    (lambda (_e _s)
+		      (ret-match+rest e s))
+		    ret-none))
+	    ret-none))))
+
+(define not-followed-by
+  (lambda (<p1> <p2>)
+    (new (*parser <p1>)
+	 (*parser <p2>) *maybe
+	 (*caten 2)
+	 (*pack-with
+	  (lambda (e1 ?e2)
+	    (with ?e2
+	      (lambda (found-e2? _)
+		`(,e1 ,found-e2?)))))
+	 (*only-if
+	  (lambda (e1+found-e2?)
+	    (with e1+found-e2?
+	      (lambda (_ found-e2?)
+		(not found-e2?)))))
+	 (*pack-with
+	  (lambda (e1 _) e1))
+	 done)))
+
+(define *followed-by (binary followed-by))
+
+(define *not-followed-by (binary not-followed-by))
+
+(define *transformer
+  (lambda (^<p>)
+    (unary (lambda (<p>) (^<p> <p>)))))
+
+;;; 
+
+(define test-string
+  (lambda (parser string)
+    (parser (string->list string)
+	    (lambda (e s)
+	      `((match ,e)
+		(remaining ,(list->string s))))
+	    (lambda (w) `(failed with report: ,@w)))))
+
+(define test
+  (lambda (parser s)
+    (parser s
+	    (lambda (e s)
+	      `((match ,e)
+		(remaining ,s)))
+	    (lambda (w) `(failed with report: ,@w)))))
+
+;;;
+
+(define file->string
+  (lambda (filename)
+    (let ((input (open-input-file filename)))
+      (letrec ((run
+		(lambda ()
+		  (let ((e (read-char input)))
+		    (if (eof-object? e)
+			(begin
+			  (close-input-port input)
+			  '())
+			(cons e (run)))))))
+	(list->string (run))))))
+
+(define read-stdin-to
+  (lambda (end-of-input)
+    (let ((end-of-input-list (string->list end-of-input)))
+      (letrec ((state-init
+		(lambda (seen)
+		  (let ((ch (read-char)))
+		    (cond ((eof-object? ch)
+			   (error 'read-stdin-to
+			     (format "Marker ~a not reached"
+			       end-of-input)))
+			  ((char=? ch (car end-of-input-list))
+			   (state-seen seen `(,ch) (cdr end-of-input-list)))
+			  (else (state-init `(,ch ,@seen)))))))
+	       (state-seen
+		(lambda (seen-before seen-now end-of-input-list-rest)
+		  (if (null? end-of-input-list-rest)
+		      (list->string
+		       (reverse seen-before))
+		      (let ((ch (read-char)))
+			(cond ((eof-object? ch)
+			       (format "Marker ~a not reached"
+				 end-of-input))
+			      ((char=? ch (car end-of-input-list-rest))
+			       (state-seen seen-before
+					   `(,ch ,@seen-now)
+					   (cdr end-of-input-list-rest)))
+			      (else (state-init
+				     `(,ch ,@seen-now ,@seen-before)))))))))
+	(state-init '())))))
+
+;;; end-of-input
+
diff --git a/qq.scm b/qq.scm
new file mode 100755
index 0000000..21a72a8
--- /dev/null
+++ b/qq.scm
@@ -0,0 +1,107 @@
+;;; qq.scm
+;;; A naive, one-level quasiquote implementation + optimizations
+;;;
+;;; Programmer: Mayer Goldberg, 2016
+;;;
+(load "project/pattern-matcher.scm")
+
+(define ^quote?
+  (lambda (tag)
+    (lambda (e)
+      (and (pair? e)
+	   (eq? (car e) tag)
+	   (pair? (cdr e))
+	   (null? (cddr e))))))
+
+(define quote? (^quote? 'quote))
+(define unquote? (^quote? 'unquote))
+(define unquote-splicing? (^quote? 'unquote-splicing))
+
+(define const?
+  (let ((simple-sexprs-predicates
+	 (list boolean? char? number? string?)))
+    (lambda (e)
+      (or (ormap (lambda (p?)
+		   ;;(display (format "Ormap ~a\n" (p? e)))
+		   (p? e))
+		 simple-sexprs-predicates)
+	  (quote? e)))))
+
+(define quotify
+  (lambda (e)
+    (if (or (null? e)
+	    (pair? e)
+	    (symbol? e)
+	    (vector? e))
+	`',e
+	e)))
+
+(define unquotify
+  (lambda (e)
+    (if (quote? e)
+	(cadr e)
+	e)))
+
+(define const-pair?
+  (lambda (e)
+    (and (quote? e)
+	 (pair? (cadr e)))))
+
+(define expand-qq
+  (letrec ((expand-qq
+	    (lambda (e)
+	      (cond ((unquote? e) (cadr e))
+		    ((unquote-splicing? e)
+		     (error 'expand-qq
+		       "unquote-splicing here makes no sense!"))
+		    ((pair? e)
+		     (let ((a (car e))
+			   (b (cdr e)))
+		       (cond ((unquote-splicing? a)
+			      `(append ,(cadr a) ,(expand-qq b)))
+			     ((unquote-splicing? b)
+			      `(cons ,(expand-qq a) ,(cadr b)))
+			     (else `(cons ,(expand-qq a) ,(expand-qq b))))))
+		    ((vector? e) `(list->vector ,(expand-qq (vector->list e))))
+		    ((or (null? e) (symbol? e)) `',e)
+		    (else e))))
+	   (optimize-qq-expansion (lambda (e) (optimizer e (lambda () e))))
+	   (optimizer
+	    (compose-patterns
+	     (pattern-rule
+	      `(append ,(? 'e) '())
+	      (lambda (e) (optimize-qq-expansion e)))
+	     (pattern-rule
+	      `(append ,(? 'c1 const-pair?) (cons ,(? 'c2 const?) ,(? 'e)))
+	      (lambda (c1 c2 e)
+		(let ((c (quotify `(,@(unquotify c1) ,(unquotify c2))))
+		      (e (optimize-qq-expansion e)))
+		  (optimize-qq-expansion `(append ,c ,e)))))
+	     (pattern-rule
+	      `(append ,(? 'c1 const-pair?) ,(? 'c2 const-pair?))
+	      (lambda (c1 c2)
+		(let ((c (quotify (append (unquotify c1) (unquotify c2)))))
+		  c)))
+	     (pattern-rule
+	      `(append ,(? 'e1) ,(? 'e2))
+	      (lambda (e1 e2)
+		(let ((e1 (optimize-qq-expansion e1))
+		      (e2 (optimize-qq-expansion e2)))
+		  `(append ,e1 ,e2))))
+	     (pattern-rule
+	      `(cons ,(? 'c1 const?) (cons ,(? 'c2 const?) ,(? 'e)))
+	      (lambda (c1 c2 e)
+		(let ((c (quotify (list (unquotify c1) (unquotify c2))))
+		      (e (optimize-qq-expansion e)))
+		  (optimize-qq-expansion `(append ,c ,e)))))
+	     (pattern-rule
+	      `(cons ,(? 'e1) ,(? 'e2))
+	      (lambda (e1 e2)
+		(let ((e1 (optimize-qq-expansion e1))
+		      (e2 (optimize-qq-expansion e2)))
+		  (if (and (const? e1) (const? e2))
+		      (quotify (cons (unquotify e1) (unquotify e2)))
+		      `(cons ,e1 ,e2))))))))
+    (lambda (e)
+      (optimize-qq-expansion
+       (expand-qq e)))))
diff --git a/readme.txt b/readme.txt
old mode 100644
new mode 100755
index e69de29..e6792db
--- a/readme.txt
+++ b/readme.txt
@@ -0,0 +1 @@
+We, Liza Fridman 316871474 Omri Danziger 204370605, assert that the work we submitted is 100% our own. We have not received any part from any other student in the class, nor have we give parts of it for use to others. Nor have we used code from other sources: Courses taught previously at this university, courses taught at other universities, various bits of code found on the internet, etc. We realize that should our code be found to contain code from other sources, that a formal case shall be opened against us with ועדת משמעת, in pursuit of disciplinary action.
diff --git a/scheme.s b/scheme.s
new file mode 100755
index 0000000..4c9818a
--- /dev/null
+++ b/scheme.s
@@ -0,0 +1,900 @@
+;;; scheme.s
+;;; Support for the Scheme compiler
+;;; 
+;;; Programmer: Mayer Goldberg, 2018
+
+%define T_UNDEFINED 0
+%define T_VOID 1
+%define T_NIL 2
+%define T_INTEGER 3
+%define T_FRACTION 4
+%define T_BOOL 5
+%define T_CHAR 6
+%define T_STRING 7
+%define T_SYMBOL 8
+%define T_CLOSURE 9
+%define T_PAIR 10
+%define T_VECTOR 11
+
+%define CHAR_NUL 0
+%define CHAR_TAB 9
+%define CHAR_NEWLINE 10
+%define CHAR_PAGE 12
+%define CHAR_RETURN 13
+%define CHAR_SPACE 32
+
+%define TYPE_BITS 4
+%define WORD_SIZE 64
+
+%define MAKE_LITERAL(type, lit) ((lit << TYPE_BITS) | type)
+
+%macro TYPE 1
+	and %1, ((1 << TYPE_BITS) - 1) 
+%endmacro
+
+%macro DATA 1
+	sar %1, TYPE_BITS
+%endmacro
+
+%macro DATA_UPPER 1
+	sar %1, (((WORD_SIZE - TYPE_BITS) >> 1) + TYPE_BITS)
+%endmacro
+
+%macro DATA_LOWER 1
+	sal %1, ((WORD_SIZE - TYPE_BITS) >> 1)
+	DATA_UPPER %1
+%endmacro
+
+%define MAKE_LITERAL_PAIR(car, cdr) (((((car - start_of_data) << ((WORD_SIZE - TYPE_BITS) >> 1)) | (cdr - start_of_data)) << TYPE_BITS) | T_PAIR)
+
+%define MAKE_LITERAL_FRACTION(num, den) (((((num - start_of_data) << ((WORD_SIZE - TYPE_BITS) >> 1)) | (den - start_of_data)) << TYPE_BITS) | T_FRACTION)
+
+;; MAKE_LITERAL_FRACTION_WITH_REGS target-address, num-address, den-address
+%macro MAKE_LITERAL_FRACTION_WITH_REGS 3
+	push rax 
+	push rbx
+	push rdi 
+	mov rax, %1 
+	mov qword [rax], %2
+	sub qword [rax], start_of_data
+	shl qword [rax], ((WORD_SIZE - TYPE_BITS) >> 1) 
+	mov rbx, %3 
+	sub rbx, start_of_data
+	or qword [rax], rbx 
+	shl qword [rax], TYPE_BITS 
+	or qword [rax], T_FRACTION 
+	pop rdi
+	pop rbx 
+	pop rax 
+%endmacro
+
+;;; MAKE_MALLOC_LITERAL_PAIR target-address, car-address, cdr-address
+%macro MAKE_MALLOC_LITERAL_PAIR 3
+	push rax 
+	push rbx 
+	push rdi
+	mov rax, %1 
+	mov qword [rax], %2
+	sub qword [rax], start_of_data
+	shl qword [rax], ((WORD_SIZE - TYPE_BITS) >> 1) 
+	mov rbx, %3 
+	sub rbx, start_of_data
+	or qword [rax], rbx 
+	shl qword [rax], TYPE_BITS 
+	or qword [rax], T_PAIR 
+	pop rdi
+	pop rbx 
+	pop rax 
+%endmacro
+
+%macro CAR 1
+	DATA_UPPER %1
+	add %1, start_of_data
+	mov %1, qword [%1]
+%endmacro
+
+%macro CDR 1
+	DATA_LOWER %1
+	add %1, start_of_data
+	mov %1, qword [%1]
+%endmacro
+
+;;; MAKE_LITERAL_CLOSURE target, env, code
+%macro MAKE_LITERAL_CLOSURE 3
+	push rax
+	push rbx
+	mov rax, %1
+	mov qword [rax], %2
+	sub qword [rax], start_of_data
+	shl qword [rax], ((WORD_SIZE - TYPE_BITS) >> 1)
+	lea rbx, [rax + 8]
+	sub rbx, start_of_data
+	or qword [rax], rbx
+	shl qword [rax], TYPE_BITS
+	or qword [rax], T_CLOSURE
+	mov qword [rax + 8], %3
+	pop rbx
+	pop rax
+%endmacro
+
+%macro CLOSURE_ENV 1
+	DATA_UPPER %1
+	add %1, start_of_data
+%endmacro
+
+%macro CLOSURE_CODE 1
+	DATA_LOWER %1
+	add %1, start_of_data
+	mov %1, qword [%1]
+%endmacro
+
+%macro MAKE_LITERAL_STRING 1+
+	dq (((((%%LstrEnd - %%Lstr) << ((WORD_SIZE - TYPE_BITS) >> 1)) | (%%Lstr - start_of_data)) << TYPE_BITS) | T_STRING)
+	%%Lstr:
+	db %1
+	%%LstrEnd:
+%endmacro
+
+%macro STRING_LENGTH 1
+	DATA_UPPER %1
+%endmacro
+
+%macro STRING_ELEMENTS 1
+	DATA_LOWER %1
+	add %1, start_of_data
+%endmacro
+
+;;; STRING_REF dest, src, index
+;;; dest cannot be RAX! (fix this!)
+%macro STRING_REF 3
+	push rax
+	mov rax, %2
+	STRING_ELEMENTS rax
+	add rax, %3
+	mov %1, byte [rax]
+	pop rax
+%endmacro
+
+%macro MAKE_LITERAL_STRING 0
+	dq MAKE_LITERAL(T_STRING,0)
+%endmacro
+
+%macro MAKE_LITERAL_VECTOR 0
+	dq MAKE_LITERAL(T_VECTOR,0)
+%endmacro
+
+%macro MAKE_LITERAL_VECTOR 1+
+	dq ((((((%%VecEnd - %%Vec) >> 3) << ((WORD_SIZE - TYPE_BITS) >> 1)) | (%%Vec - start_of_data)) << TYPE_BITS) | T_VECTOR)
+	%%Vec:
+	dq %1
+	%%VecEnd:
+%endmacro
+
+%macro VECTOR_LENGTH 1
+	DATA_UPPER %1
+%endmacro
+
+%macro VECTOR_ELEMENTS 1
+	DATA_LOWER %1
+	add %1, start_of_data
+%endmacro
+
+;;; VECTOR_REF dest, src, index
+;;; dest cannot be RAX! (fix this!)
+%macro VECTOR_REF 3
+	mov %1, %2
+	VECTOR_ELEMENTS %1
+	lea %1, [%1 + %3*8]
+	mov %1, qword [%1]
+	mov %1, qword [%1]
+%endmacro
+
+%macro MULT 2
+  push rdi
+	mov rax, %1
+	mul %2
+	mov %1, rax
+	pop rdi
+%endmacro
+
+%macro REMAINDER 2
+  push rdi
+	mov rax, %1
+	div %2
+	mov %1, rdx
+	pop rdi
+%endmacro
+
+%macro IABS 1
+	cmp %1, 0
+	jge %%cont
+	neg %1
+	%%cont:
+%endmacro
+
+%define MAKE_LITERAL_SYMBOL(string_target) (((string_target - start_of_data) << TYPE_BITS ) | T_SYMBOL)
+
+
+;;; MAKE_MALLOC_LITERAL_SYMBOL target-address, str-address
+%macro MAKE_MALLOC_LITERAL_SYMBOL 2
+	push rax 
+	mov rax, %1 
+	mov qword [rax], %2
+	sub qword [rax], start_of_data
+	shl qword [rax], TYPE_BITS 
+	or qword [rax], T_SYMBOL
+	pop rax 
+%endmacro
+
+%macro STRING_COMPARE 2
+	push rbx
+	push rcx
+	push rdx
+	push r8
+	push r9
+	mov rcx,[%1]
+	mov r9,rcx
+	mov rbx,[%2]
+	mov r8,rbx
+	STRING_LENGTH rcx
+	STRING_LENGTH rbx
+
+	cmp rcx,rbx
+	jne .names_not_equal
+
+	mov rdx,0
+
+	.cmp_loop:
+	cmp rdx,rcx
+	je .names_equal
+
+	xor rbx,rbx
+	STRING_REF bh,r9,rdx
+	STRING_REF bl,r8,rdx
+	cmp bl,bh
+	jne .names_not_equal
+
+	inc rdx
+	jmp .cmp_loop
+
+	.names_equal:
+	mov rax, const_3
+	jmp .end_macro
+
+	.names_not_equal:
+	mov rax, const_4
+
+	.end_macro:
+	pop r9
+	pop r8
+	pop rdx
+	pop rcx
+	pop rbx
+%endmacro
+
+%macro MAKE_LITERAL_STRING_WITH_REGS 2
+	shl %2, 30
+	mov rax, %2
+	or rax, %1
+	sub rax, start_of_data
+	shl rax, TYPE_BITS
+	or rax, T_STRING
+%endmacro
+
+%macro MAKE_LITERAL_VECTOR_WITH_REGS 2
+  push rdi
+	shr %2, 3
+	shl %2, 30
+	mov rax, %2
+	or rax, %1
+	sub rax, start_of_data
+	shl rax, TYPE_BITS
+	or rax, T_VECTOR
+	pop rdi
+%endmacro
+
+%define SOB_UNDEFINED MAKE_LITERAL(T_UNDEFINED, 0)
+%define SOB_VOID MAKE_LITERAL(T_VOID, 0)
+%define SOB_FALSE MAKE_LITERAL(T_BOOL, 0)
+%define SOB_TRUE MAKE_LITERAL(T_BOOL, 1)
+%define SOB_NIL MAKE_LITERAL(T_NIL, 0)
+
+%define param(offset) qword [rbp + offset]
+
+struc scmframe
+.old_rbp: resq 1
+.ret_addr: resq 1
+.env: resq 1
+.arg_count: resq 1
+.A0: resq 1
+.A1: resq 1
+.A2: resq 1
+.A3: resq 1
+.A4: resq 1
+.A5: resq 1
+endstruc
+
+%define old_rbp param(scmframe.old_rbp)
+%define ret_addr param(scmframe.ret_addr)
+%define env param(scmframe.env)
+%define arg_count param(scmframe.arg_count)
+%define A0 param(scmframe.A0)
+%define A1 param(scmframe.A1)
+%define A2 param(scmframe.A2)
+%define A3 param(scmframe.A3)
+%define A4 param(scmframe.A4)
+%define A5 param(scmframe.A5)
+%define An(n) qword [rbp + 8 * (n + 4)]
+
+
+
+section .bss
+
+extern exit, printf, scanf, malloc
+global main, write_sob, write_sob_if_not_void
+section .text
+
+gcd:
+	push rbp
+	mov rbp, rsp
+  	mov r11, r8
+  	mov r12, r9
+
+	mov rdx, qword 0
+	IABS r11
+	IABS r12
+	cmp r11, r12
+	jge .gcd_loop
+	xchg r11, r12
+	
+.gcd_loop:
+	mov rax, r11
+	cmp r12, 0
+	je .gcd_done
+	mov rdx, qword 0
+	div r12
+	mov r11, r12
+	mov r12, rdx
+	jmp .gcd_loop
+
+.gcd_done:
+	leave
+	ret
+
+simplify_fraction:
+  push rbp
+  mov rbp, rsp
+
+  call gcd 
+  mov r10, rax ;r10=gcd(r8,r9)
+  mov rax, r8
+  mov rdx, qword 0
+  CQO
+  idiv r10
+  mov r8, rax
+  mov rax, r9
+  mov rdx, qword 0
+  CQO
+  idiv r10
+  mov r9, rax
+  push r9
+  push r8 
+  leave
+  ret
+
+write_sob_undefined:
+	push rbp
+	mov rbp, rsp
+
+	mov rax, 0
+	mov rdi, .undefined
+	call printf
+
+	leave
+	ret
+
+section .data
+.undefined:
+	db "#<undefined>", 0
+
+write_sob_integer:
+	push rbp
+	mov rbp, rsp
+
+	mov rsi, qword [rbp + 8 + 1*8]
+	sar rsi, TYPE_BITS
+	mov rdi, .int_format_string
+	mov rax, 0
+	call printf
+
+	leave
+	ret
+
+section .data
+.int_format_string:
+	db "%ld", 0
+
+write_sob_char:
+	push rbp
+	mov rbp, rsp
+
+	mov rsi, qword [rbp + 8 + 1*8]
+	DATA rsi
+
+	cmp rsi, CHAR_NUL
+	je .Lnul
+
+	cmp rsi, CHAR_TAB
+	je .Ltab
+
+	cmp rsi, CHAR_NEWLINE
+	je .Lnewline
+
+	cmp rsi, CHAR_PAGE
+	je .Lpage
+
+	cmp rsi, CHAR_RETURN
+	je .Lreturn
+
+	cmp rsi, CHAR_SPACE
+	je .Lspace
+	jg .Lregular
+
+	mov rdi, .special
+	jmp .done	
+
+.Lnul:
+	mov rdi, .nul
+	jmp .done
+
+.Ltab:
+	mov rdi, .tab
+	jmp .done
+
+.Lnewline:
+	mov rdi, .newline
+	jmp .done
+
+.Lpage:
+	mov rdi, .page
+	jmp .done
+
+.Lreturn:
+	mov rdi, .return
+	jmp .done
+
+.Lspace:
+	mov rdi, .space
+	jmp .done
+
+.Lregular:
+	mov rdi, .regular
+	jmp .done
+
+.done:
+	mov rax, 0
+	call printf
+
+	leave
+	ret
+
+section .data
+.space:
+	db "#\space", 0
+.newline:
+	db "#\newline", 0
+.return:
+	db "#\return", 0
+.tab:
+	db "#\tab", 0
+.page:
+	db "#\page", 0
+.nul:
+	db "#\nul", 0
+.special:
+	db "#\x%02x", 0
+.regular:
+	db "#\%c", 0
+
+write_sob_void:
+	push rbp
+	mov rbp, rsp
+
+	mov rax, 0
+	mov rdi, .void
+	call printf
+
+	leave
+	ret
+
+section .data
+.void:
+	db "#<void>", 0
+	
+write_sob_bool:
+	push rbp
+	mov rbp, rsp
+
+	mov rax, qword [rbp + 8 + 1*8]
+	cmp rax, SOB_FALSE
+	je .sobFalse
+	
+	mov rdi, .true
+	jmp .continue
+
+.sobFalse:
+	mov rdi, .false
+
+.continue:
+	mov rax, 0
+	call printf	
+
+	leave
+	ret
+
+section .data			
+.false:
+	db "#f", 0
+.true:
+	db "#t", 0
+
+write_sob_nil:
+	push rbp
+	mov rbp, rsp
+
+	mov rax, 0
+	mov rdi, .nil
+	call printf
+
+	leave
+	ret
+
+section .data
+.nil:
+	db "()", 0
+
+write_sob_string:
+	push rbp
+	mov rbp, rsp
+
+	mov rax, 0
+	mov rdi, .double_quote
+	call printf
+
+	mov rax, qword [rbp + 8 + 1*8]
+	mov rcx, rax
+	STRING_LENGTH rcx
+	STRING_ELEMENTS rax
+
+.loop:
+	cmp rcx, 0
+	je .done
+	mov bl, byte [rax]
+	and rbx, 0xff
+
+	cmp rbx, CHAR_TAB
+	je .ch_tab
+	cmp rbx, CHAR_NEWLINE
+	je .ch_newline
+	cmp rbx, CHAR_PAGE
+	je .ch_page
+	cmp rbx, CHAR_RETURN
+	je .ch_return
+	cmp rbx, CHAR_SPACE
+	jl .ch_hex
+	
+	mov rdi, .fs_simple_char
+	mov rsi, rbx
+	jmp .printf
+	
+.ch_hex:
+	mov rdi, .fs_hex_char
+	mov rsi, rbx
+	jmp .printf
+	
+.ch_tab:
+	mov rdi, .fs_tab
+	mov rsi, rbx
+	jmp .printf
+	
+.ch_page:
+	mov rdi, .fs_page
+	mov rsi, rbx
+	jmp .printf
+	
+.ch_return:
+	mov rdi, .fs_return
+	mov rsi, rbx
+	jmp .printf
+
+.ch_newline:
+	mov rdi, .fs_newline
+	mov rsi, rbx
+
+.printf:
+	push rax
+	push rcx
+	mov rax, 0
+	call printf
+	pop rcx
+	pop rax
+
+	dec rcx
+	inc rax
+	jmp .loop
+
+.done:
+	mov rax, 0
+	mov rdi, .double_quote
+	call printf
+
+	leave
+	ret
+section .data
+.double_quote:
+	db '"', 0
+.fs_simple_char:
+	db "%c", 0
+.fs_hex_char:
+	db "\x%02x;", 0	
+.fs_tab:
+	db "\t", 0
+.fs_page:
+	db "\f", 0
+.fs_return:
+	db "\r", 0
+.fs_newline:
+	db "\n", 0
+
+write_sob_pair:
+	push rbp
+	mov rbp, rsp
+
+	mov rax, 0
+	mov rdi, .open_paren
+	call printf
+	mov rax, qword [rbp + 8 + 1*8]
+	CAR rax
+	push rax
+	call write_sob
+	add rsp, 1*8
+	mov rax, qword [rbp + 8 + 1*8]
+	CDR rax
+	push rax
+	call write_sob_pair_on_cdr
+	add rsp, 1*8
+	mov rdi, .close_paren
+	mov rax, 0
+	call printf
+
+	leave
+	ret
+
+section .data
+.open_paren:
+	db "(", 0
+.close_paren:
+	db ")", 0
+
+write_sob_pair_on_cdr:
+	push rbp
+	mov rbp, rsp
+
+	mov rbx, qword [rbp + 8 + 1*8]
+	mov rax, rbx
+	TYPE rbx
+	cmp rbx, T_NIL
+	je .done
+	cmp rbx, T_PAIR
+	je .cdrIsPair
+	push rax
+	mov rax, 0
+	mov rdi, .dot
+	call printf
+	call write_sob
+	add rsp, 1*8
+	jmp .done
+
+.cdrIsPair:
+	mov rbx, rax
+	CDR rbx
+	push rbx
+	CAR rax
+	push rax
+	mov rax, 0
+	mov rdi, .space
+	call printf
+	call write_sob
+	add rsp, 1*8
+	call write_sob_pair_on_cdr
+	add rsp, 1*8
+
+.done:
+	leave
+	ret
+
+section .data
+.space:
+	db " ", 0
+.dot:
+	db " . ", 0
+
+write_sob_vector:
+	push rbp
+	mov rbp, rsp
+
+	mov rax, 0
+	mov rdi, .fs_open_vector
+	call printf
+
+	mov rax, qword [rbp + 8 + 1*8]
+	mov rcx, rax
+	VECTOR_LENGTH rcx
+	cmp rcx, 0
+	je .done
+	VECTOR_ELEMENTS rax
+
+	push rcx
+	push rax
+	mov rax, qword [rax]
+	push qword [rax]
+	call write_sob
+	add rsp, 1*8
+	pop rax
+	pop rcx
+	dec rcx
+	add rax, 8
+
+.loop:
+	cmp rcx, 0
+	je .done
+
+	push rcx
+	push rax
+	mov rax, 0
+	mov rdi, .fs_space
+	call printf
+	
+	pop rax
+	push rax
+	mov rax, qword [rax]
+	push qword [rax]
+	call write_sob
+	add rsp, 1*8
+	pop rax
+	pop rcx
+	dec rcx
+	add rax, 8
+	jmp .loop
+
+.done:
+	mov rax, 0
+	mov rdi, .fs_close_vector
+	call printf
+
+	leave
+	ret
+
+section	.data
+.fs_open_vector:
+	db "#(", 0
+.fs_close_vector:
+	db ")", 0
+.fs_space:
+	db " ", 0
+
+write_sob_symbol:
+	push rbp
+	mov rbp, rsp
+
+	mov rax, qword [rbp + 8 + 1*8]
+	DATA rax
+	add rax, start_of_data
+	mov rax, qword [rax]
+
+	mov rcx, rax
+	STRING_LENGTH rcx
+	STRING_ELEMENTS rax
+
+.loop:
+	cmp rcx, 0
+	je .done
+	mov bl, byte [rax]
+	and rbx, 0xff
+
+	mov rdi, .simple_char
+	mov rsi, rbx
+
+	push rax
+	push rcx
+	mov rax, 0
+	call printf
+	pop rcx
+	pop rax
+
+	dec rcx
+	inc rax
+	jmp .loop
+.done:
+	leave
+	ret
+
+section .data
+	.simple_char:
+		db "%c", 0
+
+write_sob_fraction:
+	push rbp
+	mov rbp, rsp
+
+	mov rax, qword [rbp + 8 + 1*8]
+	CAR rax
+	push rax
+	call write_sob
+	add rsp, 1*8
+
+	mov rax, 0
+	mov rdi, .slash
+	call printf
+
+	mov rax, qword [rbp + 8 + 1*8]
+	CDR rax
+	push rax
+	call write_sob
+	add rsp, 1*8
+
+	leave
+	ret
+
+section	.data
+.slash:
+	db "/", 0
+
+write_sob_closure:
+	push rbp
+	mov rbp, rsp
+
+	mov rsi, qword [rbp + 8 + 1*8]
+	mov rdx, rsi
+	CLOSURE_ENV rsi
+	CLOSURE_CODE rdx
+	mov rdi, .closure
+	mov rax, 0
+	call printf
+
+	leave
+	ret
+section .data
+.closure:
+	db "#<closure [env:%p, code:%p]>", 0
+
+write_sob:
+	mov rax, qword [rsp + 1*8]
+	TYPE rax
+	jmp qword [.jmp_table + rax * 8]
+
+section .data
+.jmp_table:
+	dq write_sob_undefined, write_sob_void, write_sob_nil
+	dq write_sob_integer, write_sob_fraction, write_sob_bool
+	dq write_sob_char, write_sob_string, write_sob_symbol
+	dq write_sob_closure, write_sob_pair, write_sob_vector
+
+section .text
+write_sob_if_not_void:
+	mov rax, qword [rsp + 1*8]
+	cmp rax, SOB_VOID
+	je .continue
+	push rax
+.debug:
+	call write_sob
+	add rsp, 1*8
+	mov rax, 0
+	mov rdi, .newline
+	call printf
+	
+.continue:
+	ret
+section .data
+.newline:
+	db CHAR_NEWLINE, 0
diff --git a/semantic-analyzer.scm b/semantic-analyzer.scm
new file mode 100755
index 0000000..fe2e216
--- /dev/null
+++ b/semantic-analyzer.scm
@@ -0,0 +1,319 @@
+(load "project/tag-parser.scm")
+
+(define lambda-simple-tag?
+  (lambda (pe)
+    (and (list? pe)
+ 	 (eq? 'lambda-simple (car pe)))))
+
+(define lambda-opt-tag?
+  (lambda (pe)
+    (and (pair? pe)
+ 	 (eq? 'lambda-opt (car pe)))))
+
+(define applic-lambda-nil?
+  (lambda (expr)
+    (and (not (null? expr))
+	 (list? expr)
+	 (eq? 'applic (car expr))
+	 (lambda-simple-tag? (cadr expr))
+	 (null? (cadadr expr)))))
+
+(define remove-applic-lambda-nil
+  (lambda (expr)
+    ;;(display (format "Removing applic of lambda null for ~a\n" expr))
+    (if (applic-lambda-nil? expr)
+
+	(begin
+	  ;;(display (format "~a passed as applic-lambda-nil\n" expr))
+	  (let* ((lambda-simple (cadr expr))
+		 (body (caddr lambda-simple)))
+	    (remove-applic-lambda-nil body)))
+
+	(begin
+	  ;;(display (format "~a DIDN'T passed as applic-lambda-nil\n" expr))
+	  (if (or (not (list? expr))
+		  (not (pair? expr)))
+	      expr
+	      (map remove-applic-lambda-nil expr))))))
+;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+(define mtrx-member
+  (lambda (el mtrx)
+    (if (or (null? mtrx) (not (pair? mtrx)))
+	#f
+	(ormap (lambda (row)
+		 (member el row))
+	       mtrx))))
+
+(define var?
+  (lambda (expr)
+    (and (pair? expr)
+	 (equal? 'var (car expr)))))
+
+(define var-in-body?
+  (lambda (var)
+    (lambda (body)
+      (cond ((not (pair? body))
+	     #f)
+	    ((or (equal? var body) (member var body))
+	     #t)
+	    (else (ormap (var-in-body? var)
+			 body)))
+      )))
+
+(define bound-var?
+  (lambda (var)
+    (lambda (pe)
+      (cond ((not (pair? pe))
+	     #f)
+	    ((lambda-simple-tag? pe)
+	     ((var-in-body? var) (caddr pe)))
+	    ((lambda-opt-tag? pe)
+	     ((var-in-body? var) (cadddr pe)))
+	    (else (ormap (bound-var? var)
+			 pe))
+	    ))))
+
+(define var-set?
+  (lambda (var)
+    (lambda (pe)
+      (cond ((not (pair? pe))
+	     #f)
+	    ;;(set (var ,var) (expr))
+	    ((and (equal? 'set (car pe))
+		  (equal? var (cadr pe)))
+	     #t)
+	    (else (ormap (var-set? var)
+			 pe))))))
+
+(define var-get?
+  (lambda (var)
+    (lambda (pe)
+      (cond ((not (pair? pe))
+	     #f)
+	    ;;(var ,var)
+	    ((or (equal? var pe)
+		 (member var pe))
+	     #t)
+	    ;;(set (var ,var) (expr))
+	    ((equal? 'set (car pe))
+	     ((var-get? var) (caddr pe)))
+	    (else (ormap (var-get? var)
+			 pe))))))
+
+(define remove-param-lambda
+  (lambda (param)
+    (lambda (pe)
+      (cond ((not (pair? pe))
+	     pe)
+	    ((and (lambda-simple-tag? pe)
+		  (member param (cadr pe)))
+	     '())
+	    ((and (lambda-opt-tag? pe)
+		  (member param (append (cadr pe) (list (caddr pe)))))
+	     
+	     '())
+	    (else
+	     (map (remove-param-lambda param)
+		  pe))))))
+
+(define to-box?
+  (lambda (arg pe)
+    (let* ((var `(var ,arg))
+	   (param-removed ((remove-param-lambda arg) pe)))
+      (and ((bound-var? var) param-removed)
+	   ((var-set? var) param-removed)
+	   ((var-get? var) param-removed)
+	   ))))
+
+(define box-arg
+  (lambda (arg)
+    (lambda (pe)
+      (cond ((not (pair? pe))
+	     pe)
+	    
+	    ;;(var arg)
+	    ((and (var? pe)
+		  (equal? arg (cadr pe)))
+	     `(box-get ,pe))
+	    
+	    ;;(set (var arg) expr)
+	    ((and (equal? 'set (car pe))
+		  (equal? arg (cadadr pe)))
+	       `(box-set ,(cadr pe) ,((box-arg arg) (caddr pe))))
+	    
+	    ;;(lambda-simple (args) (body))
+	    ((lambda-simple-tag? pe)
+	     `(lambda-simple ,(cadr pe) ,(if (member arg (cadr pe))
+					     (caddr pe)
+					     ((box-arg arg) (caddr pe)))))
+	    
+	    ;;(lambda-opt (args) opt (body))
+	    ((lambda-opt-tag? pe)
+	     `(lambda-opt
+	       ,(cadr pe) ,(caddr pe)
+	       ,(if (member arg (append (cadr pe) (list (caddr pe))))
+		    (cadddr pe)
+		    ((box-arg arg) (cadddr pe)))))
+	    
+	    (else (map (box-arg arg)
+		       pe))))))
+
+(define box-body
+  (lambda (args body)
+    (cond ((null? args)
+	   body)
+	  ((to-box? (car args) body)
+	   (box-body (cdr args) ((box-arg (car args)) body)));;)
+	  (else (box-body (cdr args) body)))))
+
+(define box-lambda
+  (lambda (args body)
+    (let ((sets-to-add (map (lambda (var)
+			      `(set (var ,var) (box (var ,var))))
+			    (filter (lambda (arg)
+				      (to-box? arg body))
+				    args))))
+      (if (null? sets-to-add)
+	  body
+	  `(seq ,(append sets-to-add (if (equal? 'seq (car body))
+					(box-body args (cadr body))
+					(list (box-body args body)))))))))
+
+(define box-set
+  (lambda (pe)
+    ;;(display (format "~a in Box-Set\n" pe))
+    (cond ((or (not (pair? pe))
+	       (not (list? pe)))
+	   pe)
+	  ((lambda-simple-tag? pe)
+	     `(lambda-simple ,(cadr pe) ,(box-lambda (cadr pe) (box-set (caddr pe)))))
+	  ((lambda-opt-tag? pe)
+	   `(lambda-opt ,(cadr pe) ,(caddr pe) ,(box-lambda (append (cadr pe) (list (caddr pe))) (box-set (cadddr pe)))))
+	  (else (map box-set
+		     pe)))))
+
+;;;;;;;;;;;;;;;;;;;;;;;;
+(define index-of
+  (lambda (el lst)
+    (if (null? lst)
+	-1
+	(if (eq? (car lst) el)
+	    0
+	    (if (= -1 (index-of el (cdr lst)))
+		-1
+		(+ 1 (index-of el (cdr lst))))))))
+
+(define major-index-of
+  (lambda (el mtrx)
+    (if (member el (car mtrx))
+	0
+	(+ 1 (major-index-of el (cdr mtrx))))))
+
+(define minor-index-of
+  (lambda (el row mtrx)
+    (if (= 0 row)
+	(index-of el (car mtrx))
+	(minor-index-of el (- row 1) (cdr mtrx)))))
+
+(define lex-pe
+  (lambda (pe params env)
+    ;;(display (format "Lex-pe pe: ~a\nparams ~a\n env = ~a\n" pe params env))
+    (cond ((or (not (pair? pe))
+	       (not (list? pe)))
+	   pe)
+	  ;;Found variable
+	  ((var? pe)
+	   (let ((name (cadr pe)))
+	     (cond ((member name params)
+		    `(pvar ,name ,(index-of name params)))
+		   ((mtrx-member name env)
+		    (let* ((major (major-index-of name env))
+			   (minor (minor-index-of name major env)))
+		      `(bvar ,name ,major ,minor)))
+		   (else
+		    `(fvar ,name)))))
+	  ;;Found lambdas
+	  ((lambda-simple-tag? pe)
+	   (let ((args (cadr pe))
+		 (body (cddr pe))
+		 (new-env (cons params env)))
+	     `(lambda-simple ,args
+			     ,@(map (lambda (expr)
+				      (lex-pe expr args new-env))
+				    body))))
+	  ((lambda-opt-tag? pe)
+	   (let* ((args (cadr pe))
+		  (opt (caddr pe))
+		  (body (cdddr pe))
+		  (new-params (append args (list opt)))
+		  (new-env (cons params env)))
+	     `(lambda-opt ,args
+			  ,opt
+			  ,@(map (lambda (expr)
+				   (lex-pe expr new-params new-env))
+				 body))))
+	  (else
+	   (map (lambda (expr)
+		  (lex-pe expr params env))
+		pe)))
+	  ))
+
+(define pe->lex-pe
+  (lambda (pe)
+    (lex-pe pe '() '())))
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+(define tc-last-expr
+  (lambda (expr-lst tp?)
+    (if (null? (cdr expr-lst))
+	(list (ATP (car expr-lst) tp?))
+	(cons (ATP (car expr-lst) #f)
+	      (tc-last-expr (cdr expr-lst) tp?)))))
+
+(define ATP
+  (lambda (pe tp?)
+    (cond ((or (not (pair? pe))
+	       (eq? 'var (car pe))
+	       (eq? 'const (car pe)))
+	   pe)
+	  ((eq? 'or (car pe))
+	   `(or ,(tc-last-expr (cadr pe) tp?)))
+	  ((eq? 'if3 (car pe))
+	   (let ((test (cadr pe))
+		 (dit (caddr pe))
+		 (dif (cadddr pe)))
+	     `(if3 ,(ATP test #f)
+		   ,(ATP dit tp?)
+		   ,(ATP dif tp?))))
+	  ((eq? 'define (car pe))
+	   `(define ,(cadr pe) ,(ATP (caddr pe) #f)))
+	  ((lambda-simple-tag? pe)
+	   (let ((args (cadr pe))
+		 (body (caddr pe)))
+	     `(lambda-simple ,args ,(ATP body #t))))
+	  ((lambda-opt-tag? pe)
+	   (let ((args (cadr pe))
+		 (opt (caddr pe))
+		 (body (cadddr pe)))
+	     `(lambda-opt ,args ,opt ,(ATP body #t))))
+	  ((or (eq? 'set (car pe))
+	       (eq? 'box-set (car pe)))
+	   (let ((name (cadr pe))
+		 (value (caddr pe)))
+	     `(,(car pe) ,name ,(ATP value #f))))
+	  ((eq? 'seq (car pe))
+	   `(seq ,(tc-last-expr (cadr pe) tp?)))
+	  ((eq? 'applic (car pe))
+	   (if tp?
+	       `(tc-applic ,@(ATP (cdr pe) #f))
+	       `(applic ,@(ATP (cdr pe) #f))))
+	  (else (map (lambda (expr)
+		       (ATP expr tp?))
+		     pe)))))
+
+(define annotate-tc
+  (lambda (pe)
+    (ATP pe #f)))
+
diff --git a/sexpr-parser.scm b/sexpr-parser.scm
new file mode 100755
index 0000000..c874748
--- /dev/null
+++ b/sexpr-parser.scm
@@ -0,0 +1,483 @@
+(load "project/pc.scm")
+
+(define <whitespace>
+  (const (lambda (c)
+	   (char<=? c #\space))))
+
+(define <eol>
+  (new
+   (*parser (char #\newline))
+   (*parser <end-of-input>)
+   (*disj 2)
+   done))
+
+(define <linecomment>
+  (new
+   (*parser (char #\;))
+   (*parser <any-char>)
+   (*parser <eol>)
+   *diff
+   *star
+   (*parser <eol>)
+   (*caten 3)
+   done))
+
+(define <exprcomment>
+  (new
+   (*parser (word "#;"))
+   (*delayed (lambda () <infixaddsub>))
+   (*caten 2)
+   
+   (*parser (word "#;"))
+   (*delayed (lambda () <sexpr>))
+   (*caten 2)
+
+   (*disj 2)
+   done))
+
+(define <comment>
+  (new
+   (*parser <linecomment>)
+   (*parser <exprcomment>)
+   (*disj 2)
+   done))
+
+(define <skip>
+  (new
+   (*parser <comment>)
+   (*parser <whitespace>)
+   (*disj 2)
+   done))
+
+(define <wrap-skip>
+  (lambda (<parser>)
+    (new (*parser (star <skip>))
+	 (*parser <parser>)
+	 (*parser (star <skip>))
+	 (*caten 3)
+	 (*pack-with (lambda (_ls p _rs) p))
+	 done)))
+
+(define <boolean>
+  (new (*parser (word-ci "#t"))
+       (*pack (lambda (_) #t))
+       (*parser (word-ci "#f"))
+       (*pack (lambda (_) #f))
+       (*disj 2)
+       done))
+
+(define <namedchar>
+  (new (*parser (word-ci "lambda"))
+       (*pack (lambda (_) (integer->char 955)))
+       (*parser (word-ci "newline"))
+       (*pack (lambda (_) #\newline))
+       (*parser (word-ci "nul"))
+       (*pack (lambda (_) #\nul))
+       (*parser (word-ci "page"))
+       (*pack (lambda (_) #\page))
+       (*parser (word-ci "return"))
+       (*pack (lambda (_) #\return))
+       (*parser (word-ci "space"))
+       (*pack (lambda (_) #\space))
+       (*parser (word-ci "tab"))
+       (*pack (lambda (_) #\tab))
+       (*disj 7)
+       done))
+
+(define <hexchar>
+  (one-of-ci "0123456789abcdef"))
+
+(define <hexunicodechar>
+  (new (*parser (char #\x))
+       (*parser <hexchar>)
+       *plus
+       (*pack (lambda (cs) (string->number (list->string cs) 16)))
+       (*caten 2)
+       (*pack-with (lambda (_x hex) (integer->char hex)))
+       done))
+
+(define <visiblesimplechar>
+  (const (lambda (c) (char>? #\space))))
+
+(define <char>
+  (new (*parser (word "#\\"))
+       (*parser <namedchar>)
+       (*parser <hexunicodechar>)
+       (*parser <visiblesimplechar>)
+       (*disj 3)
+       (*caten 2)
+       (*pack-with
+	(lambda (_ char)
+	  char))
+       done))
+
+(define <natural>
+  (pack (plus (range #\0 #\9))
+	(lambda (ds) (string->number (list->string ds)))))
+
+(define <integer>
+  (new (*parser (one-of "+-"))
+	*maybe
+	(*pack-with (lambda (sign? sign)
+		      (if sign?
+			  (if (char=? sign #\+) 1 -1)
+			  1)))
+	(*parser <natural>)
+	(*caten 2)
+	(*pack-with
+	 (lambda (sign nat)
+	   (* sign nat)))
+	done))
+
+(define <fraction>
+  (new (*parser <integer>)
+       (*parser (char #\/))
+       (*parser <natural>)
+       (*caten 3)
+       (*pack-with (lambda (int _ nat) (/ int nat)))
+       done))
+
+(define <number>
+  (new (*parser <fraction>)
+       (*parser <integer>)
+       (*disj 2)
+
+       (*delayed (lambda () <symbol>))
+       *not-followed-by
+       done))
+
+(define <stringliteralchar>
+  (new (*parser <any-char>)
+       (*parser (one-of "\"\\"))
+       *diff
+       done))
+
+(define <stringmetachar>
+  (new (*parser (word "\\\\"))
+       (*pack (lambda (_) #\\))
+       (*parser (word "\\\""))
+       (*pack (lambda (_) #\"))
+       (*parser (word "\\t"))
+       (*pack (lambda (_) #\tab))
+       (*parser (word "\\f"))
+       (*pack (lambda (_) #\page))
+       (*parser (word "\\n"))
+       (*pack (lambda (_) #\newline))
+       (*parser (word "\\r"))
+       (*pack (lambda (_) #\return))
+       (*disj 6)
+       done))
+
+(define <stringhexchar>
+  (new (*parser (word "\\x"))
+       (*parser <hexchar>)
+       *star
+       (*parser (char #\;))
+       (*caten 3)
+       (*pack-with (lambda (_ hcs __)
+		     (integer->char
+		      (string->number
+		       (list->string hcs) 16))))
+       done))
+
+(define <stringchar>
+  (new (*parser <stringhexchar>)
+       (*parser <stringmetachar>)
+       (*parser <stringliteralchar>)
+       (*disj 3)
+       done))
+
+(define <string>
+  (new (*parser (char #\"))
+       (*parser <stringchar>)
+       *star
+       (*parser (char #\"))
+       (*caten 3)
+       (*pack-with
+	(lambda (_ scs __)
+	  (list->string scs)))
+       done))
+
+(define <symbolchar>
+  (one-of-ci "0123456789abcdefghijklmnopqrstuvwxyz!$^*-_=+<>?/"))
+
+(define <symbol>
+  (new (*parser <symbolchar>)
+       *plus
+       (*pack (lambda (scs) (string->symbol (string-downcase (list->string scs)))))
+       done))
+
+(define <properlist>
+  (new
+   (*parser (char #\())
+   (*delayed (lambda () <sexpr>))
+   *star
+   (*parser (char #\)))
+   (*caten 3)
+   (*pack-with
+    (lambda (_ exp __)
+      exp))
+   done))
+
+(define <improperlist>
+  (new
+   (*parser (char #\())
+   (*delayed (lambda () <sexpr>))
+   *plus
+   (*parser (char #\.))
+   (*delayed (lambda () <sexpr>))
+   (*parser (char #\)))
+   (*caten 5)
+   (*pack-with (lambda (_lb exps _dot exp _rb)
+		`(,@exps . ,exp) ))
+   done))
+
+(define <vector>
+  (new
+   (*parser (char #\#))
+   (*parser (char #\())
+   (*delayed (lambda () <sexpr>))
+   *star
+   (*parser (char #\)))
+   (*caten 4)
+   (*pack-with (lambda (_ht _lb exps _rb)
+		 (apply vector exps)))
+  done))
+
+(define <quoted>
+  (new
+   (*parser (char #\'))
+   (*delayed (lambda () <sexpr>))
+   (*caten 2)
+   (*pack-with
+    (lambda (_ expr)
+       `',expr))
+   done))
+
+(define <quasiquote>
+  (new
+   (*parser (char #\`))
+   (*delayed (lambda () <sexpr>))
+   (*caten 2)
+   (*pack-with
+    (lambda (_ expr)
+      (list 'quasiquote expr)))
+   done))
+
+(define <unquote>
+   (new
+   (*parser (char #\,))
+   (*delayed (lambda () <sexpr>))
+   (*caten 2)
+   (*pack-with
+    (lambda (_ expr)
+      (list 'unquote expr)))
+   done))
+
+(define <unquoteandsplice>
+     (new
+      (*parser (char #\,))
+      (*parser (char #\@))
+      (*delayed (lambda () <sexpr>))
+      (*caten 3)
+      (*pack-with
+       (lambda (_unq _at expr)
+	 (list 'unquote-splicing expr)))
+      done))
+
+(define <CBnamesyntax1>
+  (new
+   (*parser (char #\@))
+   (*delayed (lambda () <sexpr>))
+   (*caten 2)
+   (*pack-with
+    (lambda (_ expr)
+      `(cbname ,expr)))
+   done))
+
+(define <CBnamesyntax2>
+  (new
+   (*parser (char #\{))
+   (*delayed (lambda () <sexpr>))
+   (*parser (char #\}))
+   (*caten 3)
+   (*pack-with
+    (lambda (_lb expr _rb)
+      `(cbname ,expr)))
+   done))
+
+(define <CBname>
+  (new
+   (*parser <CBnamesyntax1>)
+   (*parser <CBnamesyntax2>)
+   (*disj 2)
+   done))
+
+(define <infixsymbol>
+  (new (*parser (one-of-ci "0123456789abcdefghijklmnopqrstuvwxyz!$_=<>?"))
+       *plus
+       (*pack (lambda (scs) (string->symbol (string-downcase (list->string scs)))))
+       done))
+
+(define <infixnumber>
+  (new (*parser <fraction>)
+       (*parser <integer>)
+       (*disj 2)
+       (*pack
+	(lambda (num)
+	  num))
+       done))
+
+(define <infixexpr>
+  (<wrap-skip>
+  (new (*parser <infixnumber>)
+       (*parser <infixsymbol>)
+       (*parser (char #\())
+       (*delayed (lambda () <infixaddsub>))
+       (*parser (char #\)))
+       (*caten 3)
+       (*pack-with (lambda (_lp expr _rp) expr))
+       (*delayed (lambda () <infix-sexpr-escape>))
+       (*disj 4)
+       
+       done)))
+
+(define <infixfuncallarrayget>
+  (<wrap-skip>
+  (new (*parser <infixexpr>)
+       (*parser (char #\[))
+       (*delayed (lambda () <infixaddsub>))
+       (*parser (char #\]))
+       (*caten 3)
+       (*pack-with (lambda (_lb expr _rb) `(vecref ,expr)))
+       (*parser (char #\())
+       (*delayed (lambda () <infixaddsub>))
+       (*parser (char #\,))
+       (*delayed (lambda () <infixaddsub>))
+       (*caten 2)
+       (*pack-with (lambda (_comma expr) expr))
+       *star
+       (*caten 2)
+       (*pack-with (lambda (first rest) `(funargs ,first ,@rest)))
+       (*parser (char #\)))
+       (*caten 3)
+       (*pack-with (lambda (_lp exprs _rp) exprs))
+       (*parser (char #\())
+       (*parser <epsilon>)
+       (*parser (char #\)))
+       (*caten 3)
+       (*pack-with (lambda (_lp eps _rp) '(funargs)))
+       (*disj 3)
+       *star
+       (*caten 2)
+       (*pack-with (lambda (id args) (letrec ((run (lambda (id args)
+						     (cond ((null? args) id)
+							   ((eq? (caar args) 'funargs) (run `(,id ,@(cdar args)) (cdr args)))
+							   ((eq? (caar args) 'vecref) (run `(vector-ref ,id ,(cadar args)) (cdr args)))
+							   (else 'wtf)))))
+				       (run id args))))
+       done)))
+       
+       
+
+(define <infixpower>
+  (new
+   (*parser <infixfuncallarrayget>)
+   (*parser (char #\^))
+   (*parser (word "**"))
+   (*disj 2)
+   (*parser <infixfuncallarrayget>)
+   (*caten 2)
+   (*pack-with (lambda (_ exp) exp))
+   *star
+   (*caten 2)
+   (*pack-with (lambda (first rest)
+		 (let* ((all (cons first rest))
+			(last (car (reverse all)))
+			(abl (reverse (cdr (reverse all)))))
+		   (fold-right (lambda (first rest) `(expt ,first ,rest)) last abl))))
+   done))
+
+(define <infixneg>
+  (new (*parser (char #\-))
+       *maybe
+       (*pack-with
+	(lambda (-? _)
+	  -?))
+       (*parser <infixpower>)
+       (*caten 2)
+       (*pack-with
+	(lambda (-? pow)
+	  (if -? `(- ,pow) pow)))
+       done))
+
+(define <infixmultdiv>
+  (new (*parser <infixneg>)
+       (*parser (one-of "*/"))
+       (*pack (lambda (sign) (if (char=? sign #\*) '* '/)))
+       (*parser <infixneg>)
+       (*caten 2)
+       *star
+       (*caten 2)
+       (*pack-with (lambda (neg negs)
+		     (fold-left (lambda (first rest)
+				  `(,(car rest) ,first ,(cadr rest))) neg negs)))
+       done))
+
+(define <infixaddsub>
+  (new (*parser <infixmultdiv>)
+       (*parser (one-of "+-"))
+       (*pack (lambda (sign) (if (char=? sign #\+) '+ '-)))
+       (*parser <infixmultdiv>)
+       (*caten 2)
+       *star
+       (*caten 2)
+       (*pack-with (lambda (md mds)
+		     (fold-left (lambda (first rest)
+				  `(,(car rest) ,first ,(cadr rest))) md mds)))
+       done))
+
+(define <infix-prefix-extension-prefix>
+  (new
+   (*parser (word "##"))
+   (*parser (word "#%"))
+   (*disj 2)
+   done))
+
+(define <infix-sexpr-escape>
+  (new
+   (*parser <infix-prefix-extension-prefix>)
+   (*delayed (lambda () <sexpr>))
+   (*caten 2)
+   (*pack-with (lambda (_ expr) expr))
+   done))
+
+(define <infix-extension>
+  (new
+   (*parser <infix-prefix-extension-prefix>)
+   (*parser <infixaddsub>)
+   (*caten 2)
+   (*pack-with (lambda (_ expr) expr))
+   done))
+
+(define <sexpr>
+  (<wrap-skip>
+  (new (*parser <boolean>)
+       (*parser <char>)
+       (*parser <number>)
+       (*parser <string>)
+       (*parser <symbol>)
+       
+       (*parser <properlist>)
+       (*parser <improperlist>)
+       (*parser <vector>)
+       (*parser <quoted>)
+       (*parser <quasiquote>)
+       
+       (*parser <unquoteandsplice>)
+       (*parser <unquote>)
+       (*parser <CBname>)
+       (*parser <infix-extension>)
+       (*disj 14)
+       done)))
+
diff --git a/tag-parser.scm b/tag-parser.scm
new file mode 100755
index 0000000..d0bc8e3
--- /dev/null
+++ b/tag-parser.scm
@@ -0,0 +1,336 @@
+(load "project/qq.scm")
+
+(define *reserved-words*
+  '(and begin cond define do else if lambda 
+	let let* letrec or quasiquote unquote
+	unquote-splicing quote set!))
+
+(define void
+  (if #f #f))
+
+(define void?
+  (lambda (expr)
+    (equal? expr void)))
+
+(define variable?
+  (lambda (expr)
+    (and (symbol? expr) (not (member expr *reserved-words*)))))
+
+(define if-dit?
+  (lambda (exprs)
+    (and (list? exprs) (eq? 'if (car exprs)) (eq? (length exprs) 3))))
+
+(define if-dit-dif?
+  (lambda (exprs)
+    (and (list? exprs) (eq? 'if (car exprs)) (eq? (length exprs) 4))))
+
+(define empty-or?
+  (lambda (expr)
+    (and (eq? 'or (car expr)) (eq? (length expr) 1))))
+
+(define single-or?
+  (lambda (expr)
+    (and (or? expr) (= (length (cdr expr)) 1))))
+
+(define or?
+  (lambda (expr)
+    (and (pair? expr) (eq? 'or (car expr)))))
+
+(define lambda?
+  (lambda (expr)
+    (and (pair? expr) (eq? 'lambda (car expr)) (>= (length expr) 3))))
+
+(define lambda-simple?
+  (lambda (expr)
+    (and (lambda? expr) (list? (cadr expr)))))
+
+(define lambda-opt?
+  (lambda (expr)
+    (and (lambda? expr) (not (or (list? (cadr expr)) (symbol? (cadr expr)))))))
+
+(define lambda-var?
+  (lambda (expr)
+    (and (lambda? expr) (symbol? (cadr expr)))))
+
+(define split$
+  (lambda (args k)
+    (if (symbol? (cdr args))
+	(k `(,(car args)) (cdr args))
+	(split$ (cdr args)
+		(lambda (man-args arg)
+		  (k (cons (car args) man-args) arg))))))
+
+(define begin?
+  (lambda (expr)
+    (and (list? expr) (eq? 'begin (car expr)))))
+
+(define define?
+  (lambda (expr)
+    (and (list? expr) (eq? 'define (car expr)) (>= (length expr) 3))))
+
+(define define-simple?
+  (lambda (expr)
+    (and (define? expr) (symbol? (cadr expr)))))
+
+(define define-MIT?
+  (lambda (expr)
+    (and (define? expr))))
+
+(define set!?
+  (lambda (expr)
+    (and (list? expr) 
+         (eq? 'set! (car expr)) 
+         (= (length expr) 3) 
+         (symbol? (cadr expr)))))
+
+(define applic?
+  (lambda (expr)
+    (and (list? expr) (not (member (car expr) *reserved-words*)))))
+
+(define and?
+  (lambda (expr)
+    (and (pair? expr) (eq? 'and (car expr)))))
+
+(define empty-and?
+  (lambda (expr)
+    (and (and? expr) (= (length (cdr expr)) 0))))
+
+(define single-and?
+  (lambda (expr)
+    (and (and? expr) (= (length (cdr expr)) 1))))
+
+(define multiple-and?
+  (lambda (expr)
+    (and (and? expr) (> (length (cdr expr)) 1))))
+
+(define let?
+  (lambda (expr)
+    (and (pair? expr) 
+         (eq? 'let (car expr))
+         (>= (length expr) 3)
+         (list? (cadr expr))
+         (andmap (lambda (lst)
+                  (and (list? lst) (= (length lst) 2)))
+                  (cadr expr))
+         (>= (length (cddr expr)) 1))))
+
+(define let*?
+  (lambda (expr)
+    (and (pair? expr) 
+         (eq? 'let* (car expr))
+         (>= (length expr) 3)
+         (list? (cadr expr))
+         (andmap (lambda (lst)
+                  (and (list? lst) (= (length lst) 2)))
+                  (cadr expr))
+         (>= (length (cddr expr)) 1))))
+
+(define letrec?
+  (lambda (expr)
+    (and (pair? expr) 
+         (eq? 'letrec (car expr))
+         (>= (length expr) 3)
+         (list? (cadr expr))
+         (andmap (lambda (lst)
+                  (and (list? lst) (= (length lst) 2)))
+                  (cadr expr))
+         (>= (length (cddr expr)) 1))))
+
+
+
+
+(define cond-clauses (lambda (exp) (cdr exp)))
+
+(define cond-test (lambda (clause) (car clause)))
+(define cond-results (lambda (clause) (cdr clause)))
+
+(define cond-first-clause (lambda (clauses) (car clauses)))
+(define cond-rest-clauses (lambda (clauses) (cdr clauses)))
+(define cond-last-clause? (lambda (clauses) (null? (cdr clauses))))
+(define cond-empty-clauses? (lambda (clauses) (null? clauses)))
+
+(define cond-else-clause? (lambda (clause) (eq? (cond-test clause) 'else)))
+
+(define cond?
+  (lambda (expr)
+    (and (pair? expr)
+	 (eq? 'cond (car expr))
+	 (list? (cdr expr))
+	 (>= (length expr) 2))))
+
+(define cond-single-clause?
+  (lambda (expr)
+    (and (cond? expr)
+	 (cond-last-clause? (cond-clauses expr)))))
+
+(define cond-test-only-clause?
+  (lambda (clause)
+    (and (not (null? (cond-test clause))) (null? (cond-results clause)))))
+
+(define quasiquote?
+  (^quote? 'quasiquote))
+  
+(define remove-duplicates
+  (lambda (lst)
+    (if (null? lst)
+      '()
+      (cons (car lst)
+            (remove-duplicates (filter (lambda (mem)
+                                        (not (equal? mem (car lst))))
+                                       (cdr lst)))))))
+
+(define remove-dup-sets
+  (lambda (pair-list)
+    (if (null? pair-list)
+      '()
+      (cons (car pair-list)
+            (remove-dup-sets (filter (lambda (pair)
+                                        (not (eq? (car pair) (caar pair-list))))
+                                       (cdr pair-list)))))))
+
+(define filter-begin
+  (lambda (lst)
+    (fold-right (lambda (x y)
+                  (if (list? x)
+                      (if (equal? (car x) 'begin)
+                          (filter-begin (append (cdr x) y))
+                          (cons x y))
+                      (cons x y)))
+                '()
+                lst)))
+
+(define parse
+  (lambda (sexpr)
+    ;;(display (format "Parsing ~a\n" sexpr))
+    (cond ((or (const? sexpr)
+	       (void? sexpr))
+	   ;;(display (format "Const or Void ~a\n" sexpr))
+	   (if (quote? sexpr)
+	       `(const ,@(cdr sexpr))
+	       `(const ,sexpr)))
+	  
+	  ((variable? sexpr)
+	   `(var ,sexpr))
+	  
+	  ((if-dit? sexpr) `(if3 ,(parse (cadr sexpr)) 
+				 ,(parse (caddr sexpr)) 
+				 ,(parse void)))
+	  
+      	  ((if-dit-dif? sexpr) `(if3 ,(parse (cadr sexpr))
+				     ,(parse (caddr sexpr)) 
+				     ,(parse (cadddr sexpr))))
+	  
+      	  ((empty-or? sexpr) (parse #f))
+	  ((single-or? sexpr) (parse (cadr sexpr)))
+      	  ((or? sexpr) 
+	   `(or (,@(map parse (cdr sexpr)))))
+	  
+	  ((applic? sexpr)
+	   `(applic ,(parse (car sexpr)) (,@(map parse
+						 (cdr sexpr)))))
+	  
+	  ((lambda-simple? sexpr) 
+	   (let ((rem-dup (remove-duplicates (cadr sexpr))))
+	     (if (< (length rem-dup) (length (cadr sexpr)))
+		 (error 'parse "Duplicated argument names in lambda-simple")
+		 `(lambda-simple ,(cadr sexpr) ,(parse `(begin ,@(cddr sexpr)))))))
+	  
+      	  ((lambda-opt? sexpr)
+	   (let* ((splitted-vars (split$ (cadr sexpr) list))
+		  (rem-dup (filter (lambda (mem)
+				     (not (eq? mem (cadr splitted-vars))))
+				   (car splitted-vars))))
+	     (if (< (length rem-dup) (length (car splitted-vars)))
+		 (error 'parse "Duplicated argument names in lambda-opt")
+		 `(lambda-opt ,@(split$ (cadr sexpr) list) ,(parse `(begin ,@(cddr sexpr)))))))
+      	  
+      	  ((lambda-var? sexpr) 
+	   `(lambda-opt () ,(cadr sexpr) ,(parse `(begin ,@(cddr sexpr)))))
+	  
+      	  ((begin? sexpr) 
+	   (cond ((null? (cdr sexpr))
+		  (parse void))
+		 ((= (length (cdr sexpr)) 1)
+		  (parse (cadr sexpr)))
+		 (else `(seq (,@(map parse (filter-begin (cdr sexpr))))))))
+	  
+	  ((define-simple? sexpr) 
+	   `(define ,(parse (cadr sexpr)) ,(parse (caddr sexpr))))
+	  ((define-MIT? sexpr) 
+	   `(define ,(parse (caadr sexpr)) ,(parse `(lambda ,(cdadr sexpr) ,(caddr sexpr)))))
+	  
+	  ((set!? sexpr)
+	   `(set (var ,(cadr sexpr)) ,(parse (caddr sexpr))))
+
+	  ((empty-and? sexpr) (parse '#t))
+	  ((single-and? sexpr) (parse (cadr sexpr)))
+	  ((multiple-and? sexpr) (parse `(if ,(cadr sexpr)
+					     (and ,@(cddr sexpr))
+					     #f)))
+
+	  ((let? sexpr)
+	   (let ((rem-dup (remove-dup-sets (cadr sexpr))))
+	     (if (< (length rem-dup) (length (cadr sexpr)))
+		 (error 'parse "Duplicated argument names in let")
+		 (parse `((lambda ,(map car (cadr sexpr)) (begin ,@(cddr sexpr))) ,@(map cadr (cadr sexpr)))))))
+	  
+	  ((let*? sexpr)
+	   (if (= (length (cadr sexpr)) 1)
+	       (parse (cons 'let (cdr sexpr)))
+	       (parse `(let (,(caadr sexpr))
+			 (let* ,(cdadr sexpr)
+			   (begin ,@(cddr sexpr)))))))
+	  
+	  ((letrec? sexpr)
+	   (let ((rem-dup (remove-dup-sets (cadr sexpr))))
+	     (if (< (length rem-dup) (length (cadr sexpr)))
+		 (error 'parse "Duplicated argument names in letrec")
+		 (parse `(let ,(map (lambda (var)
+				      (list var '#f)) 
+				    (map car (cadr sexpr)))
+			   (begin ,@(map (lambda (pair)
+					   (list 'set! (car pair) (cadr pair)))
+					 (cadr sexpr))
+				  ((lambda () ,@(cddr sexpr)))))))))
+	  
+	  
+	  ((quasiquote? sexpr)
+	   (parse (expand-qq (cadr sexpr))))
+	  
+	  ((cond? sexpr)
+	   (let* ((clauses (cond-clauses sexpr))
+		  (first-clause (cond-first-clause clauses)))
+	     ;; (cond (else result1 .. resultn))
+	     (cond ((and (= (length sexpr) 2)
+			 (eq? 'else (car first-clause)))
+		    (if (null? (cdr first-clause))
+			(error 'parse "Missing arguments in else clause in cond")
+			(parse `(begin ,@(cdr first-clause)))))
+		   
+		   ((and (>= (length sexpr) 2)
+			 (not (eq? 'else (car first-clause)))
+			 (null? (cdr first-clause)))
+		    (if (cond-last-clause? clauses)
+			;;(cond (test))
+			(parse (car first-clause))
+			;;(cond (test) clause1 clause2)
+			(parse `(let ((temp ,(car first-clause)))
+				  (if temp
+				      temp
+				      (cond ,@(cond-rest-clauses clauses)))))))
+		   
+		   ;; (cond (test result1 result2...))
+		   ((and (= (length sexpr) 2)
+			 (not (eq? 'else (car first-clause))))                		
+		    (parse `(if ,(car first-clause) (begin ,@(cdr first-clause)))))
+		   
+		   ;; (cond clause1 clause2 ...)
+		   ((and (> (length sexpr) 2)
+			 (not (eq? 'else (car first-clause))))               	    
+		    (parse `(if ,(car first-clause) (begin ,@(cdr first-clause)) (cond ,@(cddr sexpr))))))))
+	  
+	 
+	  
+	  
+	  (else (error 'parse "Failed to parse")))
+	   ))
